<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.4.3">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2018-10-18T08:07:27+09:00</updated><id>http://localhost:4000/</id><title type="html">hackerwins blog</title><subtitle>Done is better than perfect.
</subtitle><entry><title type="html">Paper 01. High Responsiveness for Group Editing CRDTs. 요약</title><link href="http://localhost:4000/paper/2018/09/14/high-responsiveness-for-group-editing-crdts.html" rel="alternate" type="text/html" title="Paper 01. High Responsiveness for Group Editing CRDTs. 요약" /><published>2018-09-14T10:00:00+09:00</published><updated>2018-09-14T10:00:00+09:00</updated><id>http://localhost:4000/paper/2018/09/14/high-responsiveness-for-group-editing-crdts</id><content type="html" xml:base="http://localhost:4000/paper/2018/09/14/high-responsiveness-for-group-editing-crdts.html">&lt;p&gt;“High Responsiveness for Group Editing CRDTs.” 공부하면서 정리한 내용&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Original paper link: &lt;a href=&quot;https://pages.lip6.fr/Marc.Shapiro/papers/rgasplit-group2016-11.pdf&quot;&gt;High Responsiveness for Group Editing CRDTs.&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;high-responsiveness-for-group-editing-crdts&quot;&gt;High Responsiveness for Group Editing CRDTs.&lt;/h2&gt;

&lt;h3 id=&quot;요약&quot;&gt;요약&lt;/h3&gt;

&lt;p&gt;공동 편집에는 빠른 응답성을 위해서 OT, CRDT와 같은 Optimistic Replication 알고리즘이 사용되고 있음.
보통 CRDT가 downstream(원격) 오퍼레이션을 처리할 때 빠름(CRDT: 지수 시간, OT: 제곱 시간). 하지만 CRDT는 upstream(로컬) 오퍼레이션 처리시 선형 시간 복잡도라서 응답성이 느림&lt;/p&gt;

&lt;p&gt;이 논문은 CRDT의 앞 부분에 “identifier data structure”라는 보조 데이터 타입을 제공해서 upstream 오퍼레이션 처리를 개선하는 방법을 제안함. identifier data structure는 동기화나 복제를 필요로 하지 않음.&lt;/p&gt;

&lt;p&gt;identifier data structure를 블록 단위 저장 접근 방식과 함께 사용하면 upstream 실행을 상당히 개선할 수 있음(무시해도 되는 정도의 메모리, 네트워크, downstream 실행 시간이 추가됨).&lt;/p&gt;

&lt;h3 id=&quot;1-도입&quot;&gt;1. 도입&lt;/h3&gt;

&lt;h4 id=&quot;optimistic-replication&quot;&gt;Optimistic Replication&lt;/h4&gt;

&lt;p&gt;공동 편집에는 응답성이 매우 중요하므로 네트워크 지연이나 문서의 락에 영향을 받지 않도록 모든 유저는 자신의 디바이스에 편집하는 문서의 리플리카를 갖고 있는데, 이를 Optimistic Replication이라 부른다.
사용자의 편집 오퍼레이션은 로컬 리플리카에 먼저 반영되고 원격에 있는 다른 사용자의 리플리카에 전송된다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;upstream 실행: 로컬 오퍼레이션을 처리&lt;/li&gt;
  &lt;li&gt;downstream 실행: 다른 사용자가 전송한 원격 오퍼레이션을 처리, 임의의 동시 편집도 해결 해야함&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;ot&quot;&gt;OT&lt;/h4&gt;

&lt;p&gt;OT는 upstream의 빠른 응답성으로 공동 편집에 사용되었지만, 각 리플리카의 히스토리를 재정렬하고 오퍼레이션을 변환해야 하므로 downstream의 처리 속도가 특히 분산 환경에서 매우 느림(O(N^2k), N: 오퍼레이션의 수, k: 리플리카 수).&lt;/p&gt;

&lt;h4 id=&quot;crdt&quot;&gt;CRDT&lt;/h4&gt;

&lt;p&gt;이를 해결하기 위해서 CRDT가 도입되었고 교환 법칙(commutative)의 오퍼레이션을 사용해서 downstream 실행시 리플리카의 일관성을 위해서 오퍼레이션을 별도로 변환하거나 정렬할 필요가 없다.
하지만 보통 CRDT 유형의 알고리즘은 upstream 처리시에 고유한 identifier를 생성하거나 조회되어야 하므로 upstream 처리가 느린 경향이 있다.&lt;/p&gt;

&lt;h4 id=&quot;block-wise-approach&quot;&gt;Block-wise approach&lt;/h4&gt;

&lt;p&gt;이를 개선하는 첫 제안은 문자를 하나하나 저장하지 않고 블록 단위로 저장하는 것이었는데, 고유한 identifier를 갖는 요소들이 줄어드므로 선형적인 처리시 유리했고 각 요소가 고유한 identifier와 같이 메타데이터를 갖고 있었으므로 메모리도 작게 사용했다. 하지만 블록으로 연결했다고 하지만 여전히 선형 시간의 복잡도를 갖고 있다.&lt;/p&gt;

&lt;h4 id=&quot;identifier-data-structure&quot;&gt;Identifier data structure&lt;/h4&gt;

&lt;p&gt;이 논문은 upstream 처리 시간을 상당히 개선할 수 있으며 대부분의 CRDT 알고리즘에 적용할 수 있는 Identifier data structure를 제안하는데, 이는 각 피어(peer)가 자신의 독립적인 구조를 갖고 있으므로 동기화 할 필요가 없고 동시성 이슈를 고려할 필요가 없다. Identifier data structure를 도입하면 본래의 알고리즘에 비해서 네트워크, 메모리 그리고 downstream 처리에 약간의 간접 비용이 있지만 무시할 정도다.&lt;/p&gt;

&lt;h3 id=&quot;2-배경-관련-crdt들&quot;&gt;2. 배경, 관련 CRDT들&lt;/h3&gt;

&lt;h4 id=&quot;231--woot&quot;&gt;2.3.1  WOOT&lt;/h4&gt;

&lt;p&gt;WOOT에서 identifier는 피어의 아이디와 삽입시 좌우측의 두 앨리먼트에 대한 링크로 구성된다. 결정론적 알고리즘으로 동일한 구역에서 요소들이 동일한 순서를 갖지만, 매우 복잡하고 처리 비용이 크다. 각 요소의 위치가 이웃 요소와 관계에 의해 결정되므로 완전히 삭제하기가 어려워서 tombstone을 사용한다. WOOT의 최적화 버전이 제안되었지만, downstream 처리 속도만 개선되었다.&lt;/p&gt;

&lt;h4 id=&quot;232-treedoc&quot;&gt;2.3.2 TreeDoc&lt;/h4&gt;

&lt;p&gt;요소의 비균형 이진 탐색트리로 요소의 identifier는 트리에서의 Path이다. 이진탐색이 가능하지만, 트리가 비균형이므로 문서의 끝에 계속해서 텍스트를 입력할 경우, 균형이 깨져서 고비용이 발생한다. 모든 피어에서 트리의 모양이 동일하며, 균형을 맞추려면 모든 피어를 동기화 해야하므로 균형을 잡는 것은 불가능하다. tombstone을 사용하지만, 특정 조건에서 제거가 가능하다.&lt;/p&gt;

&lt;h4 id=&quot;233-logoot&quot;&gt;2.3.3 Logoot&lt;/h4&gt;

&lt;p&gt;어휘 순서를 사용해서 문서의 요소의 순서를 잡는다. identifier는 3개의 정수형 튜플(1: 우선순위, 2: Upstream 피어 ID, 3: Upstream 논리 시계)의 리스트다. identifier는 배열에 저장되며, 새로운 요소 삽입을 위해서는 배열의 shift가 발생한다. (생략)&lt;/p&gt;

&lt;h4 id=&quot;234-logootsplit&quot;&gt;2.3.4 LogootSplit&lt;/h4&gt;

&lt;p&gt;Logoot의 블록버전 (생략)&lt;/p&gt;

&lt;h4 id=&quot;235-rga&quot;&gt;2.3.5 RGA&lt;/h4&gt;

&lt;p&gt;RGA는 문서에서 모든 요소는 특정 요소 뒤에 추가된다는 점을 이용한다. RGA 자료구조는 링크드 리스트로 각 요소는 내용과 다음 요소의 링크, tombstone으로 구성된다. identifier는 피어 ID, sum(삽입중 upstream 벡터 시계의 합)으로 구성된다. identifier의 순서는 피어 ID와 sum으로 판단된다.&lt;/p&gt;

&lt;h4 id=&quot;24-요약&quot;&gt;2.4 요약&lt;/h4&gt;

&lt;p&gt;빠른 반응성을 위해서 upstream에서 로그 시간 복잡도가 필요하지만, 이전 알고리즘은 이를 제공하지 못했다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;OT는 TTF tombstone&lt;/li&gt;
  &lt;li&gt;RGA와 WOOT는 tombstone&lt;/li&gt;
  &lt;li&gt;Logoot는 자체 배열을 shift해야 했으며, LogootSplit은 identifier를 관리해야 함&lt;/li&gt;
  &lt;li&gt;Treedoc은 불균형 트리를 탐색해야 함&lt;/li&gt;
  &lt;li&gt;Block 접근방식은 블록 크기에 의존적&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;사용성에 직결되는 upstream 실행시간은 매우 중요했다. RGA는 downstream 실행이 매우 우수했다.&lt;/p&gt;

&lt;h3 id=&quot;3-identifier-자료구조&quot;&gt;3. Identifier 자료구조&lt;/h3&gt;

&lt;p&gt;이 논문에서는 각 피어마다 본 알고리즘에 영향도가 작은 Identifier 자료구조를 제안한다. upstream 실행시간을 로그시간으로 수행한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/2018-09-14-high-responsiven/fe21ad0c-b50e-11e8-90df-507ecf589d46&quot; alt=&quot;screen shot 2018-09-07 at 2 27 56 pm&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;스텝 1: 사용자 액션&lt;/li&gt;
  &lt;li&gt;스텝 2: 사용자의 액션으로부터 Identifier 자료구조를 사용해서 Node를 조회&lt;/li&gt;
  &lt;li&gt;스텝 3-5: 본 알고리즘과 동일한 복제 과정&lt;/li&gt;
  &lt;li&gt;스텝 6-7: 원격 오퍼레이션을 받아서 로컬 Identifier 자료구조를 업데이트&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;idNode는 Node를 참조를 갖고 있고 반대로 Node는 idNode의 참조를 갖고 있다.&lt;/p&gt;

&lt;h4 id=&quot;31-crdt-identifier를-조회하기&quot;&gt;3.1 CRDT identifier를 조회하기&lt;/h4&gt;

&lt;p&gt;RGA와 WOOT, LogooSplit에서 문서의 노드를 조회할 때 시작작 노드부터 찾는 위치의 노드를 만날때 까지 선형탐색 한다(O(N)).&lt;/p&gt;

&lt;p&gt;Identifier 자료구조는 사용자의 수정 위치를 입력받아서 CRDT identifier를 빠르게 찾는 역할을 한다. Identifier가 순서를 갖고 있다면, Identifier 자료구조는 스킵 리스트와 같은 SortedMap이거나 혹은 weighted binary tree가 될 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/2018-09-14-high-responsiven/10a1c958-b50f-11e8-8df6-283fcd58f2b2&quot; alt=&quot;screen shot 2018-09-10 at 9 13 35 am&quot; /&gt;&lt;/p&gt;

&lt;p&gt;RGA에 identifier 자료구조(weighted tree)를 적용할 경우&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;idNode: 레퍼런스(left child, right child, parent)와 weight(하위 트리의 전체 크기), RGA 노드의 참조&lt;/li&gt;
  &lt;li&gt;RGA Node: 기본 (identifier, 내용, next 레퍼런스, tombstone)에 idNode의 참조 추가&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/2018-09-14-high-responsiven/1fe8bebc-b50f-11e8-898d-d41ef1e3d80f&quot; alt=&quot;screen shot 2018-09-10 at 9 23 01 am&quot; /&gt;&lt;/p&gt;

&lt;p&gt;사용자의 위치(pos)로 부터 특정 Node를 찾을 때, weight를 비교하면서 identifier를 검색&lt;/p&gt;

&lt;h4 id=&quot;32-downstream-에서-identifier-자료구조-업데이트하기&quot;&gt;3.2 downstream 에서 identifier 자료구조 업데이트하기&lt;/h4&gt;

&lt;p&gt;RGA에서 삽입 오퍼레이션에는 대상 노드의 identifier와 새로운 값이 포함되어 있다. 이 논문에서는 downstream에서 RGA의 기본 알고리즘으로 대상 노드가 찾아진 뒤에 identifier 자료구조를 업데이트 한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/2018-09-14-high-responsiven/2c41abd8-b50f-11e8-8d4c-508c65dc57ad&quot; alt=&quot;screen shot 2018-09-10 at 9 38 08 am&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Identifier 자료구조는 tombstone 노드를 포함하지 않으므로 deletion에는 아무처리를 하지 않고 insertion의 경우 아래와 같은 로직을 수행한다.&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;(XXX: 삭제시에도 대상 idNode를 삭제하고 weight를 업데이트 해야한다).&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/2018-09-14-high-responsiven/38e1c12a-b50f-11e8-9473-421d9ffc3083&quot; alt=&quot;screen shot 2018-09-10 at 9 51 54 am&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;33-identifier-자료구조-logoot에-적용&quot;&gt;3.3 identifier 자료구조 Logoot에 적용&lt;/h4&gt;
&lt;p&gt;(생략)&lt;/p&gt;

&lt;h3 id=&quot;4-rgatreesplit-rga--블록화--identifier-자료구조&quot;&gt;4. RGATreeSplit: RGA + 블록화 + identifier 자료구조&lt;/h3&gt;

&lt;p&gt;논문에서는 RGA가 downstream 실행에 가장 효율적인 알고리즘이고 블록 알고리즘을 적용하면, upstream과 downstream 실행을 모두 개선하므로 identifier 자료구조를 포함한 RGATreeSplit을 제안함.&lt;/p&gt;

&lt;h4 id=&quot;41-block-wise-rga-rga--블록화&quot;&gt;4.1 block-wise RGA: RGA + 블록화&lt;/h4&gt;

&lt;p&gt;이 논문에서는 block-wise RGA에는 “W. Yu. A string-wise CRDT for group editing.”에서 제안한 split과 offset 개념을 추가했다.&lt;/p&gt;

&lt;p&gt;각 노드는 다음 속성을 갖고 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;content: 메모리 효율을 위해서 tombstone화 되면, 제거 될 수 있다.&lt;/li&gt;
  &lt;li&gt;identifier: 기존 RGA identifier&lt;/li&gt;
  &lt;li&gt;nextLink: 기존 RGA의 다음 노드의 참조&lt;/li&gt;
  &lt;li&gt;offset: 사용자가 삽입한 본 위치&lt;/li&gt;
  &lt;li&gt;splitLink: split시에 다음 노드의 참조&lt;/li&gt;
  &lt;li&gt;length: 본문의 크기&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;offset x에 있는 노드를 pos로 split하면, 첫 노드의 offset은 x, 두 번째 노드의 offset은 x + pos&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/2018-09-14-high-responsiven/46c07a70-b50f-11e8-8165-7658b7743483&quot; alt=&quot;screen shot 2018-09-10 at 10 07 34 am&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;리플리카 1에서 사용자가 “ABCDEF” 삽입, identifier 는 [[1, 0], 0]&lt;/li&gt;
  &lt;li&gt;리플리카 2에서 “ABCDEF”를 전달받고 사용자가 “XY”를 pos 3에 추가, identifier 는 [[2, 1], 0]
 “ABCDEF” 블록은 “ABC”, identifier [[1, 0], 0]와 “DEF”, identifier [[1, 0], 3]로 쪼개짐&lt;/li&gt;
  &lt;li&gt;리플리카 2에서 “56789”를 마지막에 삽입 identifier는 [[2, 2], 0]&lt;/li&gt;
  &lt;li&gt;리플리카 2에서 “78” 삭제 “56789” 블록은 (“56” identifier [[2,2],0])과 (tombstone, identifier [[2, 2], 2])그리고 (“9” identifier [[2, 2], 4])로 쪼개짐.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;FINDOFFSET: identifier와 offset을 입력받아서 특정 node를 찾는 함수&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/2018-09-14-high-responsiven/508ff13e-b50f-11e8-9f91-3d5ebd6e3b84&quot; alt=&quot;screen shot 2018-09-10 at 10 23 17 am&quot; /&gt;&lt;/p&gt;

&lt;p&gt;splitLink는 identifier와 offset을 기준으로 특정 노드를 찾을 때, 성능을 위해 사용함.&lt;/p&gt;

&lt;h4 id=&quot;42-rgatreesplit의-identifier-자료구조&quot;&gt;4.2 RGATreeSplit의 identifier 자료구조&lt;/h4&gt;

&lt;p&gt;기본적으로 3절과 비슷하지만, 몇 가지 차이가 있음&lt;/p&gt;

&lt;p&gt;첫째. Identifier 자료구조와 findPosInIdentifierTree 함수의 weight에 블록 content의 크기를 반영한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/2018-09-14-high-responsiven/5b4de342-b50f-11e8-890b-ed6046b935e7&quot; alt=&quot;screen shot 2018-09-10 at 10 31 21 am&quot; /&gt;&lt;/p&gt;

&lt;p&gt;둘째. 오퍼레이션 반영시에 대상 노드를 분할해야 한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/2018-09-14-high-responsiven/6855f8c2-b50f-11e8-83c1-2a30ab65a931&quot; alt=&quot;screen shot 2018-09-10 at 1 37 57 pm&quot; /&gt;&lt;/p&gt;

&lt;p&gt;삽입 오퍼레이션은 3개(2개: 기존 노드 split, 1개: 새로운 노드)의 새로운 블록을 만들어야한다. 간단한 방법은 기존 노드를 새로운 노드의 값으로 치환하고 새로운 노드 좌측(insertBefore))과 우측(insertAfter)에 2개의 split 노드를 삽입하는 방법이다.&lt;/p&gt;

&lt;h3 id=&quot;5-평가와-실험&quot;&gt;5. 평가와 실험&lt;/h3&gt;
&lt;h4 id=&quot;51-구현&quot;&gt;5.1 구현&lt;/h4&gt;

&lt;p&gt;3절의 identifier 자료구조로 Binary weighted tree를 도입하는 경우 balanced 혹은 unbalanced(주기적 balance)의 두가지 구현 방식이 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;RGA, Logoot: TreeList(AVL 기반), 단순한 구현위해 downstream에도 별도 hashtable 없이 TreeList로 찾음&lt;/li&gt;
  &lt;li&gt;RGATreeSplit: weighted unbalanced binary tree(주기적으로 리밸런싱 수행), 리밸런싱 처리도중 응답성이 떨어질 수 있으므로 사용자가 편집을 잠시 쉬는 동안 실행 권장(실험용 구현이라 그냥 이렇게 함…)&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;52-실험&quot;&gt;5.2 실험&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;노드: Intel Xeon X3440 processors (2.53GHz), 16GB of RAM, Wheezy-x64-big-1.0 operating systems on Debian. 싱글 쓰레드.&lt;/li&gt;
  &lt;li&gt;입력: 사용자 수정 오퍼레이션을 무작위로 생성했으며, 모든 알고리즘에 대해 동일한 세트 사용&lt;/li&gt;
  &lt;li&gt;오퍼레이션의 수와 순서가 서로 다른 여섯 개의 실험(5000, 10000, 15000, 20000, 30000 및 40000개)
    &lt;h4 id=&quot;53-싱글-엘리먼트-시리즈&quot;&gt;5.3 싱글 엘리먼트 시리즈&lt;/h4&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/2018-09-14-high-responsiven/72babc58-b50f-11e8-9eab-45bf8b0457ce&quot; alt=&quot;screen shot 2018-09-10 at 3 03 25 pm&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/2018-09-14-high-responsiven/7a1e946a-b50f-11e8-8ad9-3d8723fcf8a5&quot; alt=&quot;screen shot 2018-09-10 at 3 03 49 pm&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;입력 오퍼레이션 특징: 한 요소에만 영향을 주는 수정&lt;/li&gt;
  &lt;li&gt;RGA와 RGASplit 성능이 비슷, RGATreeList와 RGATreeSplit도 성능이 비슷&lt;/li&gt;
  &lt;li&gt;예상한 대로 identifier 자료구조를 사용한 경우 upstream에서 매우 성능이 빨라짐&lt;/li&gt;
  &lt;li&gt;downstream에서 identifier 자료구조 + RGA는 성능이 소폭 하락(identifier 자료구조 업데이트 해야 하므로)&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;54-블록-시리즈-수정&quot;&gt;5.4 블록 시리즈 수정&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/2018-09-14-high-responsiven/8538104c-b50f-11e8-867e-423ebea739ac&quot; alt=&quot;screen shot 2018-09-10 at 2 05 38 pm&quot; /&gt;
&lt;img src=&quot;/assets/img/2018-09-14-high-responsiven/8d6678bc-b50f-11e8-8c69-5bec9f3f5764&quot; alt=&quot;screen shot 2018-09-10 at 3 12 39 pm&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;입력 오퍼레이션 특징: 80% 한 요소 수정과 20% 블록 수정, 블록의 평균 길이 20개&lt;/li&gt;
  &lt;li&gt;블록 기반 알고리즘이 기본 알고리즘보다 upstream과 downstream 모두에서 성능이 향상되었지만 빠른 응답을 위해 충분하지 않음&lt;/li&gt;
  &lt;li&gt;RGASplit은 시간이 지남에 따라 성능이 저하 됨.&lt;/li&gt;
  &lt;li&gt;LogootSplitAVL, TreeDoc은 원래의 RGA 알고리즘보다 다운 스트림 성능이 떨어짐&lt;/li&gt;
  &lt;li&gt;RGATreeSplit은 전반적인 성능이 가장 좋음&lt;/li&gt;
  &lt;li&gt;LogootTree는 RGATreeSplit보다 성능이 떨어지지만 블록 관리가 없어도 LogootSplitAVL과 유사한 성능 보임&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;6-결론&quot;&gt;6. 결론&lt;/h3&gt;

&lt;p&gt;이 논문에서는 CRDT 알고리즘의 응답성을 향상 시키기 위해서 블록 단위 알고리즘과 log 시간 복잡도를 위한 추가 identifier 자료구조를 제안한다. 특히, 사용자의 수정 사항을 반영하는 upstream 을 크게 개선되므로 체감 속도를 크게 향상된다.&lt;/p&gt;</content><author><name></name></author><summary type="html">“High Responsiveness for Group Editing CRDTs.” 공부하면서 정리한 내용 Original paper link: High Responsiveness for Group Editing CRDTs.</summary></entry><entry><title type="html">Idea 06. Talk is cheap. Show me the code.</title><link href="http://localhost:4000/idea/2017/08/29/talk-is-cheap-show-me-the-code.html" rel="alternate" type="text/html" title="Idea 06. Talk is cheap. Show me the code." /><published>2017-08-29T21:04:00+09:00</published><updated>2017-08-29T21:04:00+09:00</updated><id>http://localhost:4000/idea/2017/08/29/talk-is-cheap-show-me-the-code</id><content type="html" xml:base="http://localhost:4000/idea/2017/08/29/talk-is-cheap-show-me-the-code.html">&lt;blockquote&gt;
  &lt;p&gt;“Talk is cheap. Show me the code.” from Linus Torvalds&lt;/p&gt;
&lt;/blockquote&gt;</content><author><name></name></author><summary type="html">“Talk is cheap. Show me the code.” from Linus Torvalds</summary></entry><entry><title type="html">Idea 05. 디자인 태도</title><link href="http://localhost:4000/idea/2011/12/17/design-attitude.html" rel="alternate" type="text/html" title="Idea 05. 디자인 태도" /><published>2011-12-17T11:31:00+09:00</published><updated>2011-12-17T11:31:00+09:00</updated><id>http://localhost:4000/idea/2011/12/17/design-attitude</id><content type="html" xml:base="http://localhost:4000/idea/2011/12/17/design-attitude.html">&lt;p&gt;좋은 디자인으로 변경하자고 제안할 때 “이미 돌아가는 것을 왜 바꾸느냐?” 혹은 “이것은 예전에 합의한 것인데 왜 바꾸느냐?” 라는 이야기를 듣는 경우가 종종 있다.&lt;/p&gt;

&lt;p&gt;바꾸는 가장 큰 이유는 현재의 나쁜 아이디어를 고수하는 것은 가능성을 잃어버리게 하기 때문이다. 문제는 나쁜 아이디어를 만든 것보다 그것을 고수하는 것에 있다. 이것은 우리의 발목을 잡는다. 이런 집착은 탐색을 지속하며 더 나은 것을 찾기 어렵게 한다. 더 좋은 아이디어가 발견 될때 자신의 어설픈 아이디어가 옳았다는 것을 증명하거나 방어하는 것에 시간과 힘을 쓰지 말고 더 나은 아이디어를 선택할 수 있는 용기가 필요하다.&lt;/p&gt;

&lt;p&gt;우리는 중요한 사안을 너무 쉽게 결정하고 그것에 매몰되는 것은 아닌지 생각해봐야한다. 우리가 믿었던 최소 단위 원자도 쪼개지는 마당에 변경 불가능한 아이디어는 없다. 모든 아이디어는 더 나은 아이디어가 발견 될때까지 사용한다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;‘디자인 태도’란 어설픈 아이디어를 솎아내고 최후의 좋은 아이디어들을 고를 때까지 여러 가능성을 생각해보고 방향이 잡힐때까지는 ‘모든 것을 뒤집어 고려할 수 있는 의지’를 포함한다. - 비즈니스 모델의 탄생 중&lt;/p&gt;
&lt;/blockquote&gt;</content><author><name></name></author><summary type="html">좋은 디자인으로 변경하자고 제안할 때 “이미 돌아가는 것을 왜 바꾸느냐?” 혹은 “이것은 예전에 합의한 것인데 왜 바꾸느냐?” 라는 이야기를 듣는 경우가 종종 있다.</summary></entry><entry><title type="html">Idea 04. 소프트웨어 품질과 개발문화</title><link href="http://localhost:4000/idea/2011/11/28/quality_and_culture.html" rel="alternate" type="text/html" title="Idea 04. 소프트웨어 품질과 개발문화" /><published>2011-11-28T18:34:00+09:00</published><updated>2011-11-28T18:34:00+09:00</updated><id>http://localhost:4000/idea/2011/11/28/quality_and_culture</id><content type="html" xml:base="http://localhost:4000/idea/2011/11/28/quality_and_culture.html">&lt;p&gt;나와 팀은 지난 몇몇 프로젝트를 진행하는 중 소프트웨어의 품질이 개발팀의 건전한 개발문화를 통해 향상된다고 믿게 되었다. 우리가 발견하고 적용한 건전한 개발문화란 어떤 것이 있을까?&lt;/p&gt;

&lt;p&gt;첫번째. 소스코드 공동 소유다.&lt;/p&gt;

&lt;p&gt;소스코드는 개인의 소유가 아닌 팀의 공동 소유물이다. 이는 팀원들의 솔직한 커뮤니케이션 통해 이루어질 수 있다.&lt;/p&gt;

&lt;p&gt;소스코드나 일감이 개인의 소유일 경우 개인은 자신의 탑을 쌓을 확률이 높아진다. (여기서 말하는 탑은 혼자만 고칠 수 있는 코드 혹은 잘못되었지만 그 사실을 숨기고 있고 남에게 보여주기 싫은 코드,… 등이 있다.) 이런 상황에서 개발자는 메니저에게 비이상적인 개발일정을 보고하기도하고 특정한 변경이 불가능하다고 자신의 구조를 방어하기도 한다.&lt;/p&gt;

&lt;p&gt;팀이 소스코드를 공동 소유물로 여긴다면 소스코드는 더욱 건전해지고 개개인들이 만드는 기능 사이에 중복기능을 구현할 확률도 줄일 수 있다.&lt;/p&gt;

&lt;p&gt;특히 어려운 문제의 알고리즘이나 프로그램 전체의 아키텍쳐에 대해서는 상호 리뷰 혹은 짝프로그래밍이 필수 이다. 여기서 팀은 어려운 문제를 개인에게 맡기지 않고 팀의 문제로 가져간다. 주로 짝프로그래밍을 활용하는데 개인이 내리기 힘든의사 결정을 최소 두 명이상이 고민하여 결정하도록 한다. 혼자 A가 좋을까 B가 좋을까 생각하지 않고 토론을 통해서 A혹은 B를 결정한다. 역시 혼자 진행하는 것에 비해 빠른 의사 결정이 이루어진다.&lt;/p&gt;

&lt;p&gt;팀원들은 상대방의 코드를 활발하게 리딩해야한다. 이때 팀의 커뮤니케이션이 소스코드를 통해서 이루어지기도 한다. 상대방의 코드를 탐색하고 잘못된 부분에 이의를 제기해야하고 서로 이야기한 결과 잘못되었으면 과감히 수정하거나 삭제해야한다. 여기서 작성자는 자신의 코드가 지워진다는 생각은 내려놔야 한다. 코드는 팀의 소유물이니까…&lt;/p&gt;

&lt;p&gt;공동 소유가 제대로 적용된 결과로는 마치 한명이 짠 것과 같은 코딩 스타일과 프로그램 구조가 나오게 된다.&lt;/p&gt;

&lt;p&gt;두번째. 팀 학습&lt;/p&gt;

&lt;p&gt;두번째 말하고자 하는 건전한 개발 문화는 바로 팀 학습이다.&lt;/p&gt;

&lt;p&gt;팀원 중 한 사람이 새로운 프로그래밍 패러다임이나 프레임워크에 대해 공부를 한다. 그리고 자기가 알게된 내용을 팀에 전파한다. 이는 자체 세미나를 통해서 전파되기도 하고 짝프로그래밍을 통해서 전파되기도 한다. 개인 모두가 새로운 주제에 대해서 각자 공부하는 것이 아니고 관심깊게 본 다른 사람을 통해 배운다.&lt;/p&gt;

&lt;p&gt;나의 경험으로는 팀원 중 한 사람이 Functional Programming을 공부하고 리스트 처리에 대한 프레임워크를 만들어서 다른 팀원들이 좀 더 비즈니스 로직에 집중 할수 있게 도왔던적이 있다. 그 결과 개발팀은 개발 속도가 향상시킬 수 있었고 전체 소스코드의 양 또한 줄일 수 있었다.&lt;/p&gt;

&lt;p&gt;학습의 주제가 꼭 기술적인 것일 필요는 없다. 팀의 프로젝트를 도울 수 있는 어떤 것이든 상관이 없다. 예) 플레닝 포커, …&lt;/p&gt;

&lt;p&gt;건전한 개발문화를 통해 발전된 팀은 개개인의 능력도 뛰어나고 전체적으로 볼때는 한몸처럼 움직일 것이다.&lt;/p&gt;</content><author><name></name></author><summary type="html">나와 팀은 지난 몇몇 프로젝트를 진행하는 중 소프트웨어의 품질이 개발팀의 건전한 개발문화를 통해 향상된다고 믿게 되었다. 우리가 발견하고 적용한 건전한 개발문화란 어떤 것이 있을까?</summary></entry><entry><title type="html">Idea 03. 증상만 치료하지 말고, 원인을 제거하라.</title><link href="http://localhost:4000/idea/2011/11/14/eliminate-cause.html" rel="alternate" type="text/html" title="Idea 03. 증상만 치료하지 말고, 원인을 제거하라." /><published>2011-11-14T23:09:00+09:00</published><updated>2011-11-14T23:09:00+09:00</updated><id>http://localhost:4000/idea/2011/11/14/eliminate-cause</id><content type="html" xml:base="http://localhost:4000/idea/2011/11/14/eliminate-cause.html">&lt;blockquote&gt;
  &lt;p&gt;엔토니 로빈스(anthoy Robbins)는 그의 책 [내 안의 거인을 일깨우자]에서 어떤 의사의 이야기를 하고 있다. 한 의사가 물살이 빠른 강의 제방에 서 있다가, 물에 떠내려가며 살려 달라고 외치는 비명소리를 들었다. 자기 이외에는 도와줄 사람이 없다는 것을 안 그 의사는, 주저하지 않고 물 속으로 뛰어들었다. 물에 빠진 사람을 강가로 끌어 낸 뒤, 의사는, 주저하지 않고 물 속으로 뛰어들었다. 물에 빠진 사람을 강가로 끌어 낸 뒤, 의사는 인공 호흡으로 그를 소생시키려 했다. 그런데 그가 소생되기도 전에, 강에서 두 사람의 비명 소리가 들려왔다. 의사가 두 사람을 구조하여 소생시키기 무섭게, 강에서는 또다시 네사람의 비명소리가 들려 왔다. 이어서, 여덟명의 비명이 들려 왔다… 안타깝게도, 이 의사는 사람들을 구조하기에 너무 바쁜 나머지, 상류로 올라가서 도대체 누가 사람들을 물에 빠뜨리는가 찾아 볼 시간이 없었다.&lt;/p&gt;

  &lt;p&gt;Writing Solid Code P. 273 증상만 치료하는 의사
증상만 치료하지 말고, 원인을 제거하라.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;프로젝트를 진행하다 보면 개발 경험이 풍부한 개발자 임에도 불구하고 이런 실수를 저지르는 것을 자주 목격한다.&lt;/p&gt;

&lt;p&gt;계속 발전 하고 싶으면 원인을 제거하라고 말하고 싶다.&lt;/p&gt;</content><author><name></name></author><summary type="html">엔토니 로빈스(anthoy Robbins)는 그의 책 [내 안의 거인을 일깨우자]에서 어떤 의사의 이야기를 하고 있다. 한 의사가 물살이 빠른 강의 제방에 서 있다가, 물에 떠내려가며 살려 달라고 외치는 비명소리를 들었다. 자기 이외에는 도와줄 사람이 없다는 것을 안 그 의사는, 주저하지 않고 물 속으로 뛰어들었다. 물에 빠진 사람을 강가로 끌어 낸 뒤, 의사는, 주저하지 않고 물 속으로 뛰어들었다. 물에 빠진 사람을 강가로 끌어 낸 뒤, 의사는 인공 호흡으로 그를 소생시키려 했다. 그런데 그가 소생되기도 전에, 강에서 두 사람의 비명 소리가 들려왔다. 의사가 두 사람을 구조하여 소생시키기 무섭게, 강에서는 또다시 네사람의 비명소리가 들려 왔다. 이어서, 여덟명의 비명이 들려 왔다… 안타깝게도, 이 의사는 사람들을 구조하기에 너무 바쁜 나머지, 상류로 올라가서 도대체 누가 사람들을 물에 빠뜨리는가 찾아 볼 시간이 없었다. Writing Solid Code P. 273 증상만 치료하는 의사 증상만 치료하지 말고, 원인을 제거하라.</summary></entry><entry><title type="html">Idea 02. 소프트웨어, 건축물과 정원</title><link href="http://localhost:4000/idea/2011/09/28/brida.html" rel="alternate" type="text/html" title="Idea 02. 소프트웨어, 건축물과 정원" /><published>2011-09-28T03:58:00+09:00</published><updated>2011-09-28T03:58:00+09:00</updated><id>http://localhost:4000/idea/2011/09/28/brida</id><content type="html" xml:base="http://localhost:4000/idea/2011/09/28/brida.html">&lt;p&gt;파울로 코엘료의 “브리다” 의 들어가는 말에 아래와 같은 글이 적혀 있다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;건물을 세우는 사람들은 그 일에 몇 년이라는 세월을 바치기도 하지만, 결국 언젠가는 그 일을 끝내게 됩니다. 그리고 그 일을 마치는 순간, 그는 자신이 쌓아올린 벽 안에 갇히게 됩니다. 건물을 세우는 일이 끝나면, 그 삶은 의미를 잃게 되는 것입니다.
하지만 정원을 일구는 사람들도 있습니다. 그들은 몰아치는 폭풍우와 끊임없이 변화하는 계절에 맞서 늘 고생하고 쉴 틈이 없습니다. 하지만 건물과는 달리 정원은 결코 성장을 멈추지 않습니다. 또한 정원은 그것을 일구는 사람의 관심을 요구하는 동시에 그의 삶에 위대한 모험이 함께할 수 있도록 해 줍니다. 정원을 일구는 사람들은 서로를 알아봅니다. 그들은 알고 있기 때문입니다. 식물 한 포기 한 포기의 역사 속에 온 세상의 성장이 깃들어 있음을…&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;이것을 읽고 소프트웨어 생각이나는 것은 왜 일까?
지속적인 성장을 하는 소프트웨어와 그렇지 않은 소프트웨어를 보았기 때문이다.&lt;/p&gt;</content><author><name></name></author><summary type="html">파울로 코엘료의 “브리다” 의 들어가는 말에 아래와 같은 글이 적혀 있다.</summary></entry><entry><title type="html">Idea 01. 토끼굴 속으로</title><link href="http://localhost:4000/idea/2011/04/25/down-the-rabbit-hole.html" rel="alternate" type="text/html" title="Idea 01. 토끼굴 속으로" /><published>2011-04-25T21:15:00+09:00</published><updated>2011-04-25T21:15:00+09:00</updated><id>http://localhost:4000/idea/2011/04/25/down-the-rabbit-hole</id><content type="html" xml:base="http://localhost:4000/idea/2011/04/25/down-the-rabbit-hole.html">&lt;p&gt;영화 매트릭스(Matrix)에서 모피어스는 주인공 네오(키아누 리브스 분)에게 빨간색 약과 파란색 약 중 하나를 선택하라고 말한다. 파란색 약을 먹는다면 매트릭스의 세계 속에서 편하게 살 수 있었지만 네오는 ‘진짜 현실’에 대한 호기심으로 빨간색 약을 선택한다.&lt;/p&gt;

&lt;p&gt;그리고 눈앞에 펼쳐지는 광경에 경악을 금치 못한다. 앨리스가 이상한 나라를 보면서 그랬던 것처럼 말이다(영화 매트릭스는 ‘이상한 나라의 앨리스’에 대한 오마쥬 영화이다. 초반부에 나오는 ‘흰 토끼를 따라가라’는 암호는 ‘이상한 나라의 앨리스’의 장면을 패러디한 것이다.).&lt;/p&gt;

&lt;p&gt;네오와 앨리스는 바로 ‘호기심’ 때문에 편안하게 살아감을 포기하고 각각 빨간약, 토끼굴을 선택했다.&lt;/p&gt;

&lt;p&gt;메트릭스 속의 사람들은 프로그래밍 된 사회의 이미지를 소비한다. 그곳에서 나름 만족을 하며 살아가지만 실제 세상(메트릭스 밖)을 알지는 못한다. 심지어 메트릭스를 벗어난 한 사람이 다시 메트릭스에 들어가기를 원하는 장면도 나온다.&lt;/p&gt;

&lt;p&gt;하지만 호기심이 많은 사람들은 진실을 알고 싶어하고 또 모험을 갈망한다. 자신이 속한 시스템에 맞춰서 살기보다는 뭔가 다른 것을 찾기를 원한다. 위험을 감수해야 하지만 모험은 언제나 매력적이기 때문이다.&lt;/p&gt;

&lt;p&gt;난 빨간약을 선택했다. 그리고 잡스옹은 스텐포드에서 이런 말을 했다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Your time is limited, so don’t waste it living someone else’s life. Don’t be trapped by dogma — which is living with the results of other people’s thinking. Don’t let the noise of others’ opinions drown out your own inner voice. And most important, have the courage to follow your heart and intuition. They somehow already know what you truly want to become. Everything else is secondary.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;타성에 젖으면 끝이다. 용기를 갖으라고…&lt;/p&gt;</content><author><name></name></author><summary type="html">영화 매트릭스(Matrix)에서 모피어스는 주인공 네오(키아누 리브스 분)에게 빨간색 약과 파란색 약 중 하나를 선택하라고 말한다. 파란색 약을 먹는다면 매트릭스의 세계 속에서 편하게 살 수 있었지만 네오는 ‘진짜 현실’에 대한 호기심으로 빨간색 약을 선택한다.</summary></entry><entry><title type="html">Idea 00. 유능하고 경험 많은 개발자는 어디에 모여 살까?</title><link href="http://localhost:4000/idea/2011/03/20/where-is-the-developer.html" rel="alternate" type="text/html" title="Idea 00. 유능하고 경험 많은 개발자는 어디에 모여 살까?" /><published>2011-03-20T13:15:00+09:00</published><updated>2011-03-20T13:15:00+09:00</updated><id>http://localhost:4000/idea/2011/03/20/where-is-the-developer</id><content type="html" xml:base="http://localhost:4000/idea/2011/03/20/where-is-the-developer.html">&lt;p&gt;유능하고 경험 많은 개발자는 어디에 모여 살까? 우리 개발자는 매니저가 되는 것이 목표인가?&lt;/p&gt;

&lt;p&gt;2006년 가을 개발자라는 직업을 갖게되면서부터 자연스레 생긴 궁금증이다. 5년이 다되어 가는 시간동안 경험 많은 개발자들은 보기 힘었다. 왜 대부분의 개발자들은 매니저에 비해 미숙한거 같고 어리게만 느껴질까? (실제로 대부분의 개발자는 매니저에 비해 나이가 어리거나 그들의 부하직원인것 같다.)&lt;/p&gt;

&lt;p&gt;우리는 유능한 개발자들이 특정 연차가 되었을때 심화된 엔지니어링 테크를 타는 것이 아니고 매니저 테크를 타는 것을 쉽게 목격할 수 있다. 그들의 업무는 모델링, 알고리즘 풀어먹기, 불꽃 코딩 등등에서 회의하기, 메일보내기 답하기, 회의하기, 회의하기, 회의하기, 팀원이나 프로젝트의 일정이나 스펙을 관리하기, 회의하기로 바뀐다. 이제 좀 제대로 테크닉을 발휘 하면서 후임양성할때가 되었는데 개발로 부터 자연스럽게 멀어진다.&lt;/p&gt;

&lt;p&gt;일부(특히 개발을 살짝 맛만 봤다가 운이 좋게 매니저 테크를 탄) 매니저들은 개발은 쉬운 것, 애들이나 하는 것이라고 말하기도 한다.&lt;/p&gt;

&lt;p&gt;짧은 내 경험에서 알게된  개발(여기서 말하는 개발은 주로 엔지니어링)은 어렵다. 많은 것을 공부해야한다. 다양한 프로그래밍 언어는 물론이고 때로는 큰 규모의 프로그램을 구조화 하는 모델링 기법 혹은 알고리즘들, 수학에 관련되었을 수도 있고 새로나온 플렛폼 혹은 여러가지 프로그래밍 페러다임일 수도 있다. 최적의 제품을 제대로 만들기 위해서는 반드시 무엇인 가를 알아야 하고 공부해야할 경우가 있다. 개발자는 경력이 쌓일 수록 이런 것들을 공부해야 한다.(만약 아닌것 같고 그게 이글을 읽고 있는 사람이라면 제발 공부해라.) 특정 상황에선 현재로서는 해결할 수 없는 문제가 발생되기도 한다.  끊임없이 실험하고 방법을 찾으려고 시도할때는 꿈에서도 생각할 정도로 몰입해야하는 상황도 생긴다. 개발자라는 직업이 현실에는 의사, 변호사 같은 다른 전문직보다 진입장벽이 낮지만 그들은 사실 전문가이어야하고 전문직이어야 한다. 그래야 제대로 만들 수 있다.&lt;/p&gt;

&lt;p&gt;물론 매니저라는 직업이 나쁘다는 말을 하고 싶은 것이 아니다. 그들은 프로젝트에 필요한 직업이고 해야할 일이 있다. 매니지먼트 스킬은 엔지니어링 스킬과 조금 다른 테크이다. 난 단지 유능한 개발자들이 어설픈 매니저(물론 매니저가 더 맞고 천직이라고 느껴지면 가도 좋다.)가 되지 않고 유능한 개발자로 남아서 자신이 가지고 있는 기술을 풀어 먹었으면 좋을것 같다는 생각을 하는 것이다. 그러면 좋은 소프트웨어가 좀 더 많이 나오지 않을까? 하는 생각이든다.&lt;/p&gt;</content><author><name></name></author><summary type="html">유능하고 경험 많은 개발자는 어디에 모여 살까? 우리 개발자는 매니저가 되는 것이 목표인가?</summary></entry></feed>