<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.8.5">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2018-11-19T09:37:58+09:00</updated><id>http://localhost:4000/</id><title type="html">hackerwins blog</title><subtitle>Done is better than perfect.
</subtitle><entry><title type="html">Paper 03. OpSets: Sequential Specifications for Replicated Datatypes (Extended Version). 요약</title><link href="http://localhost:4000/paper/2018/11/08/opsets.html" rel="alternate" type="text/html" title="Paper 03. OpSets: Sequential Specifications for Replicated Datatypes (Extended Version). 요약" /><published>2018-11-08T10:33:00+09:00</published><updated>2018-11-08T10:33:00+09:00</updated><id>http://localhost:4000/paper/2018/11/08/opsets</id><content type="html" xml:base="http://localhost:4000/paper/2018/11/08/opsets.html">&lt;p&gt;“OpSets: Sequential Specifications for Replicated Datatypes (Extended Version).” 공부하면서 정리한 내용&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Original paper link: &lt;a href=&quot;https://arxiv.org/abs/1805.04263&quot;&gt;link&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;opsets-sequential-specifications-for-replicated-datatypes-extended-version&quot;&gt;OpSets: Sequential Specifications for Replicated Datatypes (Extended Version)&lt;/h1&gt;

&lt;h2 id=&quot;요약&quot;&gt;요약&lt;/h2&gt;

&lt;p&gt;이 논문은 분산 시스템에서 최종적인 일관성(eventual consistency)의 복제 데이터타입(replicated datatype)을 구현한 프레임워크인 OpSets를 제안한다. 또 이런 유형의 데이터타입(CRDT)을 구현하는 알고리즘을 기계적으로 검증한다. 이는 간단하지만 표현력이 뛰어나므로 맵(map), 집합(set), 리스트(list), 텍스트(text), 그래프(graph), 트리(tree) 및 레지스터(register)를 비롯한 다양한 추상 데이터타입을 간단히 적용할 수 있다. 또 데이터타입을 복잡한 데이터 구조를 구성할 수 있다. 복제 알고리즘을 분석하기 위한 OpSet의 기능을 알아보기 위해, 이전부터 간과되었지만 협업 텍스트 편집에서 중요한 정확성(correctness property)에 대해 살펴본다. 정확성을 만족시키지 않는 알고리즘은 텍스트 공동편집시 의도하지 않은 글자가 삽입되는 현상이 나타난다. OpSets를 사용해서 정확성을 정의하고 기존 복제 알고리즘들이 정확성을 충족시키는지 확인한다. 또한 새로운 복제 된 데이터타입을 개발하는 데 OpSets를 사용하는 방법에 대해서 알아본다. 기존에는 잠금장치(Lock)를 사용하지 않고 구현하기 어려웠던 트리에서 원자적 이동 Operation에 대해 알아본다. 이 논문은 이전의 비공식 접근 방식의 모호함을 없애고 추론 오류를 배제하기 위해서 Isabelle/HOL 증명 도구를 사용해서 OpSets를 공식화하고 주요 주장의 정확성에 대해서 기계적으로 증명한다.&lt;/p&gt;

&lt;h3 id=&quot;1-도입&quot;&gt;1. 도입&lt;/h3&gt;

&lt;p&gt;공통적인 분산 시스템의 요구 사항은 여러 노드가 공유 데이터에 동시에 접근하고 조작하는 것이다. 예를 들어, 노트북을 사용하는 기자의 공유 텍스트 문서 작업부터 공통 데이터베이스를 조작하는 웹 서버들이 있다. 이때 공유 데이터가 일정한 일관성을 보장하도록 하는 것이 중요하다. 예를 들어 serializability 또는 linearizability와 같은 강력한 일관성 모델(strong consistency models)은 실제로 복제되고 동시에 실행되는 경우에도 시스템이 연속적으로 실행되는 단일 노드처럼 작동한다. 이 모델의 단점은 모든 동작이나 트랜잭션이 완료되기 전에 네트워크 통신을 기다려야 한다는 것이다. 따라서 일관성이 강한 시스템에서는 노드가 오프라인이거나 다른 노드들과 단절된 상태(network partition)에서 작업을 진행할 수 없다.&lt;/p&gt;

&lt;p&gt;반면에 최종적인 일관성은 각 참여자가 오프라인 상태에서 공유 데이터 구조의 로컬 복사본(replica)을 수정할 수 있지만 그 정의가 빈약하다. “공유 상태에 대한 새로운 업데이트가 없으면 모든 노드의 데이터는 결국 동일하다”에서 “새로운 업데이트가 없으면”이라는 전제는 공유 상태가 지속적으로 수정되면 (예를들어 시스템이 절대로 정지되지 않는 경우) 참이 될 수 없다. 또한 최종적인 일관성의 정의에는 최종 상태가 적합한지 여부를 명시하지 않았다.&lt;/p&gt;

&lt;p&gt;CRDT는 최근 몇 년 동안 주목을 받아온 복제된 상태의 추상화이다. CRDT의 주요 정확성(correctness property)은 수렴(convergence)이다. “두 개의 복제본이 동일한 업데이트들을 적용 할 때, 동일한 복제본이 다른 순서로 업데이트를 적용하더라도 동일한 상태로 수렴한다. 이는 최종적인 일관성보다 단단하지만, 수렴 상태가 정확히 무엇인지를 정의하지는 않았다.&lt;/p&gt;

&lt;p&gt;이 논문은 복제 된 데이터 형식적 의미론(Formal semantics)을 정의하고 동시에 데이터에 접근하거나 조작하기 위한 알고리즘에 대한 새로운 접근 방식, Operation Sets(OpSets for short)를 제안한다. OpSets은 일부 업데이트들이 적용된 후 복제본의 허용된 상태를 정확하게 정의하는 실행 가능한 스팩이다. 이 논문의 공헌은 다음과 같다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;2절에서는 동시 편집 데이터 구조의 일관성에 대한 지정 및 추론을 위한 간단한 추상화 OpSet을 소개한다.&lt;/li&gt;
  &lt;li&gt;3절과 5절에서는 OpSet의 다양한 추상 데이터타입(맵, 세트, 리스트, 텍스트, 그래프, 트리 및 레지스터)를 소개하며, 이 스펙이 간단하고 정확하다는 점에 대해 알아본다.&lt;/li&gt;
  &lt;li&gt;4절에서는 OpSet를 사용하여 기존 알고리즘을 추론하는 방법을 알아본다. 이 분야의 선행 연구에서 간과 되어온 협업 텍스트 편집을 위해 중요한 정확성(correctness property)에 대해 살펴본다. 이 논문 저자는 OpSet 스펙이 정확성을 올바르게 정의한 첫 번째라고 주장한다. 텍스트 편집 CRDT에서 정확성을 만족시키지 못하는 몇 가지 다른 사례들을 살펴본다.&lt;/li&gt;
  &lt;li&gt;5절에서는 OpSet를 사용하여 새로운 복제 된 데이터타입을 개발하는 방법에 대해 알아본다. 특히 트리 CRDT에서 원자 이동 Operation을 정의하는 방법을 소개한다. 이 작업은 트리 내의 새 위치로 하위 트리를 이동하거나 맵에서 키의 이름을 바꾸거나 리스트에서 항목의 순서를 변경하는 데 사용할 수 있다. OpSets 접근 방식은 그 동안 잠금장치(Lock) 없이 구현할 수 없던 작업을 간단하게 정의할 수 있다.&lt;/li&gt;
  &lt;li&gt;Isabelle/HOL 증명 도구를 사용하여 OpSets를 공식화하고 이 논문의 주요 주장의 정확성에 대한 기계화 된 증명을 산출한다. 특히 공동 텍스트 편집의 최근 스펙인 Attiya 보다 더 엄격하게 입증한다. 기계화 된 교정을 사용함으로써 이전의 비공식적 인 접근 방법의 모호성 없이 텍스트 수정에서 발생할 수있는 추론 오류를 배제한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;2-opsets-접근방식&quot;&gt;2. OpSets 접근방식&lt;/h3&gt;

&lt;p&gt;OpSets 접근방식은 복제 된 데이터 시스템의 일관성을 설명하기 위한 간단한 추상화이다. 이 절에서는 일반적인 접근 방식에 대해 알아보고 3절, 5절에서 구체적인 데이터 구조와 스펙을 설명한다.&lt;/p&gt;

&lt;h4 id=&quot;21-시스템-모델&quot;&gt;2.1 시스템 모델&lt;/h4&gt;

&lt;p&gt;대상 시스템은 네트워크에 연결된 노드 집합으로 구성된다. 각 노드는 관계형 데이터베이스(row를 갖은 테이블), 텍스트 문서(문자 시퀀스), 벡터 그래프 문서(그래프 개체의 레코드 트리), 파일 시스템(디렉토리, 파일의 트리) 등의 데이터에 접근한다.&lt;/p&gt;

&lt;p&gt;새 노드는 언제든지 추가 할 수 있으며 사전에 노드 집합을 알 필요는 없다. 노드는 모바일 장치와 같이 일시적으로 다른 노드와 통신 할 수 없다고 가정한다. 노드는 오프라인에서도 언제든지 공유 데이터(shared data)에 접근할 수 있어야한다. 따라서 각 노드는 공유 데이터의 로컬 사본(copy)을 가지며, 다른 노드와의 통신 또는 조정을 기다리지 않고 공유 데이터를 읽고 수정할 수 있다.&lt;/p&gt;

&lt;p&gt;노드가 공유 데이터를 수정하면 변경 사항을 Operation으로 기록한다. 예를 들어, 텍스트 문서의 특정 위치에 삽입을 Operation으로 표현한다. 각 노드는 로컬에 Operation의 집합, OpSet을 관리한다. 노드가 공유 데이터를 변경하면 OpSet에 해당 Operation을 추가하고 Operation이 포함된 메시지를 다른 노드에 전송한다. 노드가 다른 노드에서 메시지를 수신 하면, 해당 메시지의 Operation이 수신자의 로컬 OpSet에 추가된다. Operation은 전체 과정에서 변경되지 않는다(Immutable).&lt;/p&gt;

&lt;p&gt;네트워크의 신뢰성에 대해서는 아무런 가정을 하지 않는다. 메시지는 손실(lost)되거나 중복(duplicate)되거나 임의 순서(reordered)로 전달 될 수 있다. 실제 네트워크의 특성을 반영하여 가능한 경우 손실 된 메시지를 재전송한다고 가정하지만 (예 : TCP 사용) 네트워크 또는 노드 오류로 인해 메시지가 영구적으로 손실 될 수 있다. 각 노드의 OpSet은 단조롭게(monotonically) 증가하는 Operation 집합이므로 두 통신 노드는 표준 조합 연산자 ∪(Union)을 사용하여 OpSets를 병합 할 수 있다. OpSets의 합집합은 교환 법칙(commutative), 결합 법칙(associative), 멱등 법칙(idempotent)이 적용 되므로 통신중인 노드가 동일한 OpSet 내용으로 수렴(converge)된다.&lt;/p&gt;

&lt;p&gt;각 Operation은 고유 ID를 갖고 있으며, 모든 노드는 다른 노드와 통신하지 않고 새 ID의 생성이 가능하며 Operation ID는 전체 시스템에서 순서를 매길 수 있다고 가정한다(total ordering). 램포트 시계(Lamport timestamp)를 ID로 사용하면 이 요구 사항을 쉽게 충족시킬 수 있다. 램포트 시계는 다음과 같이 (counter, nodeID)로 구성된 쌍이다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;counter는 정수(integer)다. Operation ID 생성시, 로컬 OpSet의 기존 Operation ID 중 최대값을 하나 증가시켜서 할당한다.&lt;/li&gt;
  &lt;li&gt;nodeID는 ID를 생성하는 노드를 고유하게 식별하는 문자열이다(예: UUID).&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;서로 다른 노드가 동일한 카운터 값을 갖는 ID가 생성될 수도 있지만, 각 노드는 엄격하게 단조롭게 증가하는 카운터 값으로 ID를 생성하므로 ID는 전역적으로 고유하다(nodeID가 고유하므로). Operation ID에 대한 전체 순서는 다음과 같이 정의한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/2018-11-08-opsets/image6.png&quot; alt=&quot;image1&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;22-opset-해석하기&quot;&gt;2.2 OpSet 해석하기&lt;/h4&gt;

&lt;p&gt;대부분의 Operation 기반 CRDT는 노드의 로컬 상태가 Operation에 의해 어떻게 조작되는지를 기술하지만 이 논문은 복제된 데이터 타입을 다른 방식으로 설명한다.&lt;/p&gt;

&lt;p&gt;OpSets 접근 방식은 공유 데이터 구조가 직접 조작되지 않는다. 대신 OpSet &lt;code class=&quot;highlighter-rouge&quot;&gt;O&lt;/code&gt;를 해석 함수&lt;code class=&quot;highlighter-rouge&quot;&gt;[-]&lt;/code&gt;를 사용해서 공유 데이터의 현재 상태인 &lt;code class=&quot;highlighter-rouge&quot;&gt;[O]&lt;/code&gt;를 반환한다. 해석 함수(interpretation function)는 순수 함수, 즉 결정적(deterministic)이고, 부수효과가 없으므로(no side effect), 그 결과는 O에만 의존한다. 시스템의 모든 노드는 동일한 해석 함수를 사용한다.&lt;/p&gt;

&lt;p&gt;결과적으로 두 노드가 동일한 OpSet &lt;code class=&quot;highlighter-rouge&quot;&gt;O&lt;/code&gt;에 대해서 공유 데이터의 &lt;code class=&quot;highlighter-rouge&quot;&gt;[O]&lt;/code&gt;에 대한 값도 동일하다. 이 구성은 최종적인 일관성(eventual consistency)을 보장한다. 두 노드가 동일한 OpSet으로 수렴하므로 OpSet에서 결정적으로 파생 된 모든 데이터도 수렴한다(convergence).&lt;/p&gt;

&lt;p&gt;원칙적으로 결정적 함수(deterministic function)는 해석 함수로 사용될 수 있다. 그러나 CRDT의 의미론(semantics)을 정의 할 때(3절과 5절 참조) 한 번에 하나의 Operation을 해석하도록 &lt;code class=&quot;highlighter-rouge&quot;&gt;[-]&lt;/code&gt;를 분리하는 것(specialize)이 유용했다.&lt;/p&gt;

&lt;p&gt;OpSet &lt;code class=&quot;highlighter-rouge&quot;&gt;O&lt;/code&gt;는 페어(id, op)의 집합이다. 여기서 id는 고유 한 Operation 식별자이고 op는 발생한 수정 내용의 설명이다. 2.1절에서 설명한 것처럼 식별자는 전체 순서가 보장된다고 가정한다. 임의의 OpSet에 대해서 모든 Operation들은 Operation ID에 의한 오름차순 순서가 있음을 알 수 있다. 해석 함수를 하나씩 적용할 때 각 Operation의 의미론을 정의할 수 있다.&lt;/p&gt;

&lt;p&gt;형식적으로 OpSet O의 해석 함수 &lt;code class=&quot;highlighter-rouge&quot;&gt;[O]&lt;/code&gt;는 다음과 같이 정의 한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/2018-11-08-opsets/image17.png&quot; alt=&quot;image17&quot; /&gt;&lt;/p&gt;

&lt;p&gt;여기서, &lt;code class=&quot;highlighter-rouge&quot;&gt;interp[S, (id, op)]&lt;/code&gt;는 상태 S의 Operation (id, op) 해석이고, InitialState는 복제 데이터 타입의 최소 상태(예를 들어, 빈 트리 또는 빈 리스트)이다. 즉, S가 id보다 작은 식별자를 가진 모든 Operation을 해석 한 결과라면, &lt;code class=&quot;highlighter-rouge&quot;&gt;interp[S, (id, op)]&lt;/code&gt;는 (id, op)가 추가 된 OpSet의 해석이다. 예를 들어, &lt;code class=&quot;highlighter-rouge&quot;&gt;id1 &amp;lt;id2 &amp;lt;id3&lt;/code&gt; 인 경우 다음과 같다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/2018-11-08-opsets/image4.png&quot; alt=&quot;image4&quot; /&gt;&lt;/p&gt;

&lt;p&gt;OpSet의 Operation 순서가 고유하므로, 해석 &lt;code class=&quot;highlighter-rouge&quot;&gt;interp[S(id, op)]&lt;/code&gt;가 결정적이라면 OpSet 해석 함수 &lt;code class=&quot;highlighter-rouge&quot;&gt;[-]&lt;/code&gt;도 결정적이다.&lt;/p&gt;

&lt;h4 id=&quot;23-잘못된-순서로out-of-order-메시지-수신하기&quot;&gt;2.3 잘못된 순서로(out of order) 메시지 수신하기&lt;/h4&gt;

&lt;p&gt;많은 컴퓨팅 시스템들은 Operation들을 전체 순서로 추가하고 그 순서대로 실행 한다는 규칙을 기반으로 한다. 예를 들어, 직렬화 트랜잭션(serializable transactions)과 상태 머신 복제(state machine replication)는 이 접근법을 따른다. 그러나 2.2절에서 설명한 OpSet 해석은 대부분의 시스템보다 약한 순서 개념(weaker notion of ordering)을 사용한다는 점을 주목하자.&lt;/p&gt;

&lt;p&gt;직렬화 트랜잭션 이나 상태 머신 복제에서 트랜잭션/Operation의 특정 상태에서 실행한 결과는 내구성(durable)이 있어야 한다. 따라서, 특정 트랜잭션 Ti를 실행하기 전에, 시스템은 Ti보다 낮은 ID를 갖는 보류중인 트랜잭션 이 없는지 확인해야 한다(Ti보다 먼저 실행 되야함). 그렇지 않으면 이후 ID가 낮은 트랜잭션이 도착하면 Ti가 실행 된 상태가 무효화되기 때문이다. 그러나 이 전제 조건을 보장하는 것은 비용이 많이 든다. 6.1절에서 살펴보지만 적어도 노드 쿼럼과의 통신이 필요하다. ID가 램포트 시간이면 모든 단일 노드와의 통신이 필요하다. 많은 노드가 오프라인인 경우에는 시스템은 어떤 트랜잭션도 실행할 수 없다.
반대로 2.1절의 시스템 모델은 모든 노드가 오프라인 일 때도 노드가 항상 공유 데이터를 읽고 수정할 수 있다. 또한 네트워크에서 순서 보장을 가정하지 않는다. 특정 노드의 OpSet O에 특정 Operation &lt;code class=&quot;highlighter-rouge&quot;&gt;(id1, op1) ∈ O&lt;/code&gt;를 만족할 때 &lt;code class=&quot;highlighter-rouge&quot;&gt;(id2, op2)&lt;/code&gt;를 포함하는 메시지를 수신 할 수 있는데, 여기서 &lt;code class=&quot;highlighter-rouge&quot;&gt;id2 &amp;lt;id1&lt;/code&gt; 즉, 나중에 도착한 Operation을 OpSet 해석 &lt;code class=&quot;highlighter-rouge&quot;&gt;[O]&lt;/code&gt;의 기존 Operation &lt;code class=&quot;highlighter-rouge&quot;&gt;(id1, op1)&lt;/code&gt;보다 먼저 적용하는 것이 필요할 수 있다.&lt;/p&gt;

&lt;p&gt;OpSet 모델에서 이러한 비 순차적 인 Operation의 전달은 문제가 되지 않는다. Operation의 수신 순서는 OpSet O에는 아무런 영향을 미치지 않으며, 해석 함수가 순수하고 부수효과가 없다고 가정하기 때문에 해석 작업은 새로운 Operation이 O에 추가 될 때마다 항상 다시 계산된다(&lt;strong&gt;XXX: 실제품에 사용이 가능할까?&lt;/strong&gt;). 해석 함수는 일련의 Operation을 해석 할 때 예상되는 결과를 정의하는 실행 가능 스펙이다. 이 방식으로 복제 된 데이터타입을 구현하면 두 가지 중요한 이점이 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;다른 CRDT 알고리즘 정의와 다르게 해석 함수 &lt;code class=&quot;highlighter-rouge&quot;&gt;interp[S(id, op)]&lt;/code&gt;는 다른 Operation과 관련하여 commute할 필요가 없다. 어떤 순수한 함수도 사용할 수 있다. 이는 3절과 5절에서 볼 수 있듯이 Operation 해석을 기술하는 일이 훨씬 간단해진다.&lt;/li&gt;
  &lt;li&gt;기술한 각 데이터타입의 구현의 존재를 스펙 자체로 보장 할 수 있다. 이는 구현할 수 없는 공리적 명세와는 달리, 공리적 설명을 만족시키는 구현이 존재 함을 입증하기 위해 추가 작업이 필요하다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;노드가 잠재적으로 동일한 하위 Operation 집합을 반복적으로 적용하기 때문에 순수 OpSet 해설은 실제 구현보다 성능이 저하 될 수 있다. 따라서 OpSet 기반 스펙을 만족하고 CRDT의 효율적인 (그리고 아마도 가장 복잡한) 알고리즘의 구현은 4절에서 알아본다.&lt;/p&gt;

&lt;p&gt;OpSet 모델을 기반으로 실용적인 JavaScript CRDT 구현체를 개발했고 몇 가지 장점을 발견했다. 예를 들어, 문서의 모든 편집 버전이 해석이므로 문서의 편집 내역을 쉽게 검사 할 수 있다. 특정 작업의 하위 집합 또한, OpSets를 사용하면 누락 된 Operation이 이전에 단절된 노드의 OpSets에 재전송되어 추가 될 수 있으므로 네트워크 파티션, 장애로부터 복구 할 수 있는 간단한 메커니즘을 제공한다. 하지만 이 구현의 세부 사항은 이 논문의 범위를 벗어난다.&lt;/p&gt;

&lt;h3 id=&quot;3-리스트-맵-레지스터-그래프-정의하기&quot;&gt;3. 리스트, 맵, 레지스터, 그래프 정의하기&lt;/h3&gt;

&lt;p&gt;3장에서는 일반적 데이터구조(예: 사용자 지정 키와 값의 맵), 리스트(값의 선형 순서)과 같은 예제 의미를 정의하여 OpSets를 구체적으로 구현한다. 맵 데이터 타입은 세트도 표현할 수 있다(키를 세트의 구성원으로 사용하고 값을 무시). 리스트 데이터 유형은 텍스트로 표현할 수 있다(각 문자를 리스트 요소에 매핑). 리스트와 맵 모두 값은 기본형 데이터(숫자, 문자열)나 다른 맵 또는 리스트에 대한 참조 이다. 이러한 참조를 사용하여 객체 지향 프로그래밍 언어에서 처럼 임의의 객체 그래프를 구성 할 수 있다. 5장에서는 이 객체 그래프를 트리로 제한하는 방법을 알아본다.&lt;/p&gt;

&lt;p&gt;맵의 키와 리스트의 요소는 다중 값 레지스터(multi-value register)로 처리한다. 즉, 동일한 맵 키 또는 리스트 요소에 여러 값이 동시에 할당되는 경우, 쓰여지는 모든 값을 유지한다. 이 때문에, 맵 키 또는 리스트 요소를 읽어는 일은, 유저가 명시적으로 병합할 수 있도록 복수의 값을 반환할 수 있다. 맵 키 또는 리스트 요소에 새 값을 할당하면 이전의 모든 값(casually preceding value)을 덮어 쓴다. last-writer-wins(동시에 작성된 값 중 하나를 승자로 선택)와 같은 레지스터 동작을 쉽게 정의 할 수 있다.&lt;/p&gt;

&lt;h4 id=&quot;31-operation-생성하기&quot;&gt;3.1 Operation 생성하기&lt;/h4&gt;

&lt;p&gt;일반적 데이터 구조의 OpSet에는 다음과 같이 6가지 유형의 Operation이 포함된다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;(id, MakeMap)&lt;/code&gt;은 id로 식별되는 비어있는 새 맵 객체를 만든다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;(id, MakeList)&lt;/code&gt;는 id로 식별되는 비어있는 새 리스트 객체를 만든다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;(id, MakeVal(val))&lt;/code&gt;는 id로 식별되는 기본형 값 val(i.g.: 숫자, 문자열 또는 boolean)을 할당한다. 이 Operation은 값을 감싸는데 사용하며 값으로 기본형 혹은 맵 또는 리스트에 대한 참조로 갖는다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;(id, InsertAfter(ref))&lt;/code&gt;는 id로 식별되는 새 요소를 만들어서 리스트에 삽입한다. ref가 MakeList Operation의 ID 인 경우, 새로운 요소가 리스트의 head에 삽입된다. 혹은 ref는 기존 리스트 요소의 ID(예: InsertAfter Operation)이어야 하며, 이 경우 새 리스트 요소는 참조한 요소 바로 다음에 삽입된다. InsertAfter Operation에서는 값을 새 요소에 할당하지 않고 이는 Assign Operation에 의해 수행된다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;(id, Assign(obj, key, val, prev))&lt;/code&gt;는 맵의 키에 새로운 값을 할당한다(obj가 이전 MakeMap Operation의 ID 인 경우) 또는 list 요소(obj가 MakeList Operation). 맵 할당의 경우 key는 업데이트 할 사용자 지정 키이며 문자열 또는 정수와 같은 기본 값이 된다. 리스트의 경우, key는 갱신 할 리스트 요소의 ID(즉, 이전의 InsertAfter Operation의 ID)이다. val은 값의 ID이며 MakeMap, MakeList 또는 MakeVal Operation을 식별 할 수 있다. prev는 동일한 객체의 동일한 키에 대한 이전 Assign Operation 들의 ID 집합이며 현재 Operation으로 덮어 쓴다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;(id, Remove(obj, key, prev))&lt;/code&gt;는 맵에서 키-값 쌍을 제거하거나 리스트에서 요소를 제거한다. 할당과 마찬가지로 obj는 업데이트한 객체를 생성 한 이전 MakeMap 또는 MakeList Operation의 ID이며 key는 제거할 키 또는 리스트 요소를 식별한다. prev는 동일한 객체의 동일한 키에 대한 이전 Assign Operation의 ID 집합이며 현재 Operation에 의해 제거된다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;위 Operation 생성의 의사 코드는 부록 A에 있다.&lt;/p&gt;

&lt;h4 id=&quot;32-operation-해석하기&quot;&gt;3.2 Operation 해석하기&lt;/h4&gt;

&lt;p&gt;2.2절에서 주어진 순차적 OpSet 해석을 사용한다. map 및 list 데이터 구조의 현재 상태를 인코딩하기 위해 관계 페어(E, L)를 사용한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;요소 관계 &lt;code class=&quot;highlighter-rouge&quot;&gt;E ⊆ (ID × ID × (ID ∪ Key) × ID)&lt;/code&gt;: 맵 키와 리스트 요소에 현재 할당 된 값을 포함하는 4- 튜플 집합. &lt;code class=&quot;highlighter-rouge&quot;&gt;(id, obj, key, val) ∈ E&lt;/code&gt;이면 id를 가진 Assign Operation은 obj를 가진 객체를 업데이트하여 val 값을 map key 또는 list element key에 할당한다. Obj가 리스트 오브젝트를 참조하면, key는 리스트 관계 L에있는 요소의 ID이다(아래 참조). Obj 객체를 참조하는 경우 문자열이나 정수와 같은 기본형을 키로 사용할 수 있다.&lt;/li&gt;
  &lt;li&gt;리스트 관계 &lt;code class=&quot;highlighter-rouge&quot;&gt;L ⊆ (ID × (ID ∪ {⊥}))&lt;/code&gt;: 리스트 요소의 순서를 나타내는 페어의 집합이다. &lt;code class=&quot;highlighter-rouge&quot;&gt;(prev, next) ∈ L&lt;/code&gt;이라면, prev를 갖는 리스트 요소 바로 다음에 ID가 next 인 요소가 뒤따라 온다. &lt;code class=&quot;highlighter-rouge&quot;&gt;(last, ⊥) ∈ L&lt;/code&gt;을 사용하여 리스트 요소에 마지막임을 알 수 있다. head는 리스트 obj의 첫 번째 요소이고 (obj는 리스트를 생성 한 MakeList Operation의 ID) &lt;code class=&quot;highlighter-rouge&quot;&gt;(obj, head) ∈ L&lt;/code&gt;을 가진다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;초기에는 두 관계가 비어 있다. 즉, &lt;code class=&quot;highlighter-rouge&quot;&gt;[∅] = InitialState = (∅, ∅)&lt;/code&gt;이다. 그리고 다음과 같이 여섯 가지 Operation 유형의 해석을 정의한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/2018-11-08-opsets/image10.png&quot; alt=&quot;image10&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Assign, Remove의 해석은 E 만 업데이트하고 L은 변경하지 않는다. 반대로 InsertAfter와 MakeList의 해석은 L만 업데이트 한다. Assign, Remove 해석은 튜플을 인과 관계로 이전 Assign(prev의 ID가 ID로 표시되는 튜플)에서 제거하지만 동시 할당의 튜플은 변경하지 않는데 이는 다중 값 레지스터의 동작이다. last-writer-wins 레지스터가 필요한 경우 &lt;code class=&quot;highlighter-rouge&quot;&gt;id’ ∈/ prev&lt;/code&gt; 조건을 &lt;code class=&quot;highlighter-rouge&quot;&gt;obj’ != obj ∨ key’ != key&lt;/code&gt;로 변경하면 동일한 객체 ID와 키를 가진 기존 튜플을 제거 할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/2018-11-08-opsets/image2.png&quot; alt=&quot;image2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;InsertAfter의 해석은 그림 1 에서처럼 링크 된 목록에 삽입하는 것과 유사하다.
예를 들어, &lt;code class=&quot;highlighter-rouge&quot;&gt;(id, InsertAfter(ref))&lt;/code&gt;를 해석하기 위해서, &lt;code class=&quot;highlighter-rouge&quot;&gt;(ref, next) ∈ L&lt;/code&gt;가 주어지면, &lt;code class=&quot;highlighter-rouge&quot;&gt;L&lt;/code&gt;에서 페어 &lt;code class=&quot;highlighter-rouge&quot;&gt;(ref, next)&lt;/code&gt;을 제거하고 페어 &lt;code class=&quot;highlighter-rouge&quot;&gt;(ref, id)&lt;/code&gt;과 &lt;code class=&quot;highlighter-rouge&quot;&gt;(id, next)&lt;/code&gt;를 &lt;code class=&quot;highlighter-rouge&quot;&gt;L&lt;/code&gt;에 추가한다. 따라서 새 리스트 요소 id가 ref와 next 사이에 삽입된다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;L&lt;/code&gt;은 축소되지 않으며 InsertAfter Operation을 해석하면 커진다. 리스트의 요소가 Remove Operation에 의해 제거되면 요소 관계 &lt;code class=&quot;highlighter-rouge&quot;&gt;E&lt;/code&gt;의 리스트 요소에서 값은 제거되지만 요소는 tombstone(삭제 표시)으로 &lt;code class=&quot;highlighter-rouge&quot;&gt;L&lt;/code&gt;에 남아 있기 때문에 동시에 발생한 InsertAfter Operation에서 여전히 해당 값을 찾을 수 있다. 따라서 사용자의 관점에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;E&lt;/code&gt; 요소 관계에 적어도 하나의 연관된 값이 있으면 리스트 요소만 존재한다. 연관된 값이 없는 모든 리스트 요소는 무시되어야한다.&lt;/p&gt;

&lt;h3 id=&quot;4-텍스트-편집-병합하기&quot;&gt;4. 텍스트 편집 병합하기&lt;/h3&gt;

&lt;p&gt;3장에서 설명한 데이터타입은 광범위한 애플리케이션에 사용할 수 있다. 예를 들어 리스트 데이터 타입을 사용하여 협업 텍스트 편집기를 구현할 수 있다. 텍스트를 개별 문자 리스트로 처리하고 모든 편집을 리스트에 삽입 또는 삭제 Operation의 순서로 표현한다.&lt;/p&gt;

&lt;p&gt;협업 텍스트 편집 문제는 OT와 CRDT라는 두 가지 주요 접근법으로 연구되었다. 6장에서 알아본다. 이제 협업 텍스트 편집에 대해 이전 작업에서 고려하지 않은 시나리오에 대해 알아본다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/2018-11-08-opsets/image7.png&quot; alt=&quot;image7&quot; /&gt;&lt;/p&gt;

&lt;p&gt;그림 2의 예제에서는 두 명의 사용자가 초기 상태가 “Hello!”라는 텍스트 문서를 동시에 편집하고 있다. 왼쪽 사용자가 “Hello Alice!”로 변경하고 오른쪽 사용자는 문서를 “Hello Charlie!”로 변경한다. 동시 편집 내용이 병합되면 알고리즘에 따라 “Alice”와 “Charlie”의 두 삽입이 문자별로 임의로 인터리빙(interleaving)되면 뜻이 모호한 문자가 된다. 동시 삽입이 단 하나의 단어가 아니라 전체 단락이나 섹션이라면 문제는 더욱 심각한데, 사용자의 삽입을 인터리빙하면 대부분 이해할 수 없는 텍스트가 남아서 다시 작성해야 한다. 그림 2의 병합은 정상 동작은 아니지만 이런 인터리빙 삽입을 제외하는 협업 텍스트 편집의 공식 스펙은 없다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/2018-11-08-opsets/image18.png&quot; alt=&quot;image18&quot; /&gt;&lt;/p&gt;

&lt;p&gt;정리 1. Attiya et al.의 협업 텍스트 Astrong 스펙은 그림 2의 결과가 된다. 즉, 동시 삽입을 동일한 위치에 인터리빙하는 알고리즘은 Astrong 스펙을 만족시킨다. 또한 텍스트 편집 CRDT 알고리즘 인 Logoot 및 LSEQ도 이 결과가 반영된다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/2018-11-08-opsets/image8.png&quot; alt=&quot;image8&quot; /&gt;&lt;/p&gt;

&lt;p&gt;증명. 각 문자를 전체 정렬한 식별자 공간(total ordered identifier space)에서 위치를 할당하는 아이디어에 기반한 각각의 정의에서 식별자의 순서가 문서의 문자 순서와 일치한다. 새로운 문자가 삽입되면 이전 문자와 후속 문자의 식별자 사이에 있는 식별자가 할당된다. 그러나 동일한 전임-후임 요소의 Operation을 가진 동시 삽입이 수행 될 때 이러한 삽입은 임의로 정렬된다. 따라서 동일한 전임-후임 요소 내에서 반복되는 삽입은 임의로 인터리빙 될 수 있다.&lt;/p&gt;

&lt;p&gt;또한 Logoot와 LSEQ의 오픈 소스 구현을 사용하여 테스트를 수행했을 때 이러한 인터리빙이 실제로 발생하는 것을 관찰했다.&lt;/p&gt;

&lt;p&gt;더 나은 방법은 특정 사용자의 모든 삽입을 연속 시퀀스로 유지해서 문자를 인터리빙하지 않고 병합하는 것이다. 이 조건에서는 그림 2의 예가 “Hello Alice Charlie!”또는 “Hello Charlie Alice!”라는 두 가지 병합된 결과가 된다. 이 두 결과 간의 선택은 임의적이다. 한 사용자의 삽입이 다른 것보다 먼저 오기 위한 사전 요구 사항이 없기 때문이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/2018-11-08-opsets/image9.png&quot; alt=&quot;image9&quot; /&gt;&lt;/p&gt;

&lt;p&gt;정리 2. 3절의 리스트 스펙은 동시 삽입의 인터리빙을 허용하지 않는다. 즉, 한 사용자가 문자 시퀀스 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;x1, x2,. . . , xn&amp;gt;&lt;/code&gt; 삽입하고 다른 사용자는 동시에 문자 시퀀스 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;y1, y2,. . . , ym&amp;gt;&lt;/code&gt;을 같은 위치에 삽입한 경우 병합 문서에는 문자 시퀀스 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;x1, x2,. . . , xn, y1, y2,. . . , ym&amp;gt;&lt;/code&gt; 또는 문자 시퀀스 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;y1, y2 ,. . . , ym, x1, x2,. . . , xn&amp;gt;&lt;/code&gt; 의 결과가 된다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/2018-11-08-opsets/image5.png&quot; alt=&quot;image5&quot; /&gt;&lt;/p&gt;

&lt;p&gt;증명. Isabelle/HOL 증명 도구를 사용하여 리스트 스펙과 정리 2를 형식화했다. 형식 증명 구현은 부록 C.3에 요약했다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/2018-11-08-opsets/image11.png&quot; alt=&quot;image11&quot; /&gt;&lt;/p&gt;

&lt;p&gt;그림 3은 인터리빙의 제거 이유를 설명한 그림 2와 유사한 편집 시나리오지만 “Alice”와 “Charlie”의 삽입은 각각 “Al”과 “Ch”로 단축했다. 이 예제에는 여섯 가지 가능한 방법으로 정렬 할 수 있는 네 가지 삽입 Operation( “A”, “l”, “C”, “h”)이 있다. 그러나 6가지 동작의 결과는 ChAl 또는 AlCh 두 가지 결과 만 가능하며 CAhl 또는 AChl과 같은 인터리빙은 발생하지 않는다.&lt;/p&gt;

&lt;p&gt;실제로 최종 결과는 각각 “A”와 “C”를 삽입하는 Operation의 상대적 순서에만 의존한다. 다른 모든 Operation은 결과에 영향을 미치지 않고 재정렬 될 수 있다. 따라서 삽입 된 문자열이 2자보다 길더라도 상대 순서는 첫 번째 문자의 ID에만 의존한다. 나머지 문자도 초기 문자 뒤에 온다.&lt;/p&gt;

&lt;p&gt;4가지 Operation의 결과는 6가지 문자 순서만 있고 4가지 문자 순서는 없는데, 식별자에 대한 램포트 시계 정렬은 인과 관계 순서의 선형 확장이기 때문이다(2.1 절에 설명한). 이 예에서는 텍스트가 왼쪽에서 오른쪽으로 입력된다고 가정한다(즉, “A”는 항상 “l”앞에 삽입되고 “C”는 “h”앞에 삽입). 이것은 “l”을 삽입하는 Operation의 ID가 “A”삽입보다 크고, “h”삽입이 “C”삽입보다 커야 함을 의미한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/2018-11-08-opsets/image13.png&quot; alt=&quot;image13&quot; /&gt;&lt;/p&gt;

&lt;p&gt;정리 3의 OpSet 리스트 스펙은 Attiya et al의 Astrong 스펙보다 엄격하다. 즉, 3절에 주어진 리스트 스펙을 만족시키는 알고리즘도 Astrong을 만족하지만 그 반대는 성립하지 않는다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/2018-11-08-opsets/image15.png&quot; alt=&quot;image15&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Astrong 스펙을 Isabelle/HOL로 형식화하고 3절의 리스트 스펙을 실행할 때마다 Astrong의 모든 조건을 충족한다는 기계적으로 검증 된 증거를 제시한다. 공식 증명 구현은 부록 C.5에 요약했다. 스펙이 엄격하고 강하다는 사실은 정리 1과 2를 따른다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/2018-11-08-opsets/image16.png&quot; alt=&quot;image16&quot; /&gt;&lt;/p&gt;

&lt;p&gt;정리 4 : RGA 알고리즘은 이 논문에서 소개한 OpSet리스트 명세를 만족시키는 반면, Logoot와 LSEQ는 그렇지 않다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/2018-11-08-opsets/image14.png&quot; alt=&quot;image14&quot; /&gt;&lt;/p&gt;

&lt;p&gt;증명. 부록 C.4에서 설명한대로 RGA가 우리의 명세를 만족 시킨다는 것을 증명하기 위해 Isabelle/HOL을 사용한다. Isabelle/HOL의 RGA 구현은 이전 연구의 형식화를 기반으로한다. Logoot와 LSEQ가 스펙을 만족시키지 못한다는 사실은 정리 1과 2를 따른다.&lt;/p&gt;

&lt;h3 id=&quot;5-복제-된-트리-데이터타입&quot;&gt;5. 복제 된 트리 데이터타입&lt;/h3&gt;

&lt;p&gt;3장에서는 복제 된 객체 그래프 데이터타입의 OpSet 사양을 제시했는데, 모든 맵 또는 리스트 객체는 고유 한 ID(즉, 객체를 만든 MakeMap 혹은 MakeList Operation의 ID)를 가지며 객체는 이 ID를 사용하여 서로를 참조 했다.&lt;/p&gt;

&lt;p&gt;이제 이 모델을 기반으로 객체 그래프가 항상 트리가 되도록 제한하는 방법을 알아보자. 트리는 모든 vertex가 정확히 하나의 parent(root 제외)를 갖고 parent 관계에 사이클이 없는 그래프이다. 트리 데이터타입은 많은 애플리케이션에서 유용하다. 예를 들어, 파일 시스템(디렉토리 및 파일로 구성)과 XML 또는 JSON 문서가 트리이다. 이 트리의 branch 노드는 맵 또는 리스트 일 수 있으며 리프 노드는 기본형 값(MakeVal Operation로 래핑 됨)이다.&lt;/p&gt;

&lt;h4 id=&quot;51-move-operation-문제&quot;&gt;5.1 Move Operation 문제&lt;/h4&gt;

&lt;p&gt;트리 데이터를 사용하는 애플리케이션에서 종종 필요한 작업중 하나는 트리 내의 새 위치로 하위 트리를 이동하는 것이다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;파일 시스템에서 디렉토리 이름 변경은 디렉토리 노드를 이전 이름에서 새 이름으로 이동하는 것으로 표현할 수 있다. 마찬가지로 디렉토리를 새 경로로 이동하기도 한다.&lt;/li&gt;
  &lt;li&gt;벡터 그래픽 애플리케이션에서 여러 객체를 논리 단위로 그룹화하는데, 그룹을 나타내는 새 branch 노드를 만든 다음 개별 객체를 해당 그룹 노드의 하위 노드로 이동하여 표현한다.&lt;/li&gt;
  &lt;li&gt;To-do list 애플리케이션에서 사용자는 리스트의 순서를 사용하여 우선 순위를 나타내며 항목을 drag&amp;amp;drop으로 순서를 변경한다. 항목 재정렬은 항목을 리스트 내의 새로운 위치로 이동하는 것과 같다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이전 위치의 하위 트리를 삭제하고 새 위치에서 다시 작성하여 Move Operation을 기본적(naively)으로 표현할 수 있다. 그러나 두 명의 사용자가 이 프로세스를 동시에 수행하는 경우 결과 트리에는 이동 된 하위 트리에 두번 복제 된다. 이는 위에 제공된 모든 애플리케이션에서 바람직하지 않다. 따라서 동시 이동의 경우 중복 객체를 생성하지 않는 Atomic Move Operation이 필요하다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/2018-11-08-opsets/image3.png&quot; alt=&quot;image3&quot; /&gt;&lt;/p&gt;

&lt;p&gt;그림 4에 좀 더 미묘한 충돌을 표현는데, B를 A의 하위 항목으로 이동하고 동시에 A를 B의 하위 항목으로 이동한다. CRDT가 이 상황을 감지하지 못하면 그림 4 (a)와 같이 병합 결과처럼 상호 참조가 발생한다. 이 결과는 더 이상 트리가 아니다. 그러한 충돌하는 Move Operation을 다루는 것은 어려운 문제이며, 트리 CRDT의 기존 구현들은 이 문제에 대한 적절한 해결책을 찾지 못했다.&lt;/p&gt;

&lt;p&gt;XML과 JSON 데이터에 대한 여러 CRDT 트리 데이터타입이 제안되었지만, 누구도 Move Operation을 정의하지 않았다. Tao et al.은 충돌하는 브랜치 노드(디렉토리)가 복제되고 리프 노드(파일)가 여러 브랜치 노드에서 참조 될 수 있는 CRDT 기반의 복제 된 파일 시스템을 구현하여 그림 4(b)와 같은 동시 동작을 해결했다. 따라서 엄격하게는 Tao 데이터 구조는 DAG(Directed acyclic graph)이며 트리가 아니다.&lt;/p&gt;

&lt;p&gt;Najafzadeh는 또한 CRDT 기반의 복제 된 파일 시스템을 구현했지만 다른 접근 방법을 선택했다. Move Operation은 시작 전에 전역 잠금(Lock)을 획득해야 하며 충돌하는 동시 Move Operation이 처음에는 발생할 수 없도록 보장해야한다. 이러한 보수적 인 접근 방식은 Move 충돌을 배제하지만, 일부 Operation의 경우 매우 일관된 동기화가 필요하기 때문에 엄밀하게는 CRDT가 아니다.&lt;/p&gt;

&lt;h4 id=&quot;52-원자-이동-가능한-트리tree-with-atomic-moves&quot;&gt;5.2 원자 이동 가능한 트리(Tree with Atomic Moves)&lt;/h4&gt;

&lt;p&gt;이제 자유롭게 원자 이동이 가능한 트리 CRDT를 정의하고 OpSets 접근 방식의 장점에 대해 알아보자. 이 트리는 그림 4의 a, b 상황과 같은 트리 구조에 위반 없고 동시 이동으로 트리가 복제되는 일이 발생하지 않는다. 또한 잠금 장치(Lock) 이나 전역 동기화가 필요없다.&lt;/p&gt;

&lt;p&gt;OpSet에서 충돌하는 Move Operation이 발생하면, 그 중 하나를 선택하고 적용한 뒤 다른 작업은 무시한다. 따라서 그림 4에서, 두 개의 상반되는 이동 동작의 병합 된 결과는 (c) 또는 (d) 중 하나이다. 두 사용자가 동일한 항목을 다른 위치로 동시에 이동하면 큰 ID로 Move Operation이 항목의 최종 위치를 결정한다. 그러나 비 충돌 상황에서는 모든 동시 Move Operation이 적용된다.&lt;/p&gt;

&lt;p&gt;트리를 3장에 명시된 제한된 형태의 객체 그래프를 정의한다. 먼저 지정된 루트 객체가 필요한데, 다른 모든 Operation ID보다 (2.1절에서 소개한 전체 식별자 순서 중) 작은 Operation ID의 루트가 있다고 가정한다. 그리고 임의의 OpSet O를 트리로 정의한다면 루트 노드가 리스트나 맵인지에 따라 &lt;code class=&quot;highlighter-rouge&quot;&gt;(root, MakeList) ∈ O&lt;/code&gt; 또는 &lt;code class=&quot;highlighter-rouge&quot;&gt;(root, MakeMap) ∈ O&lt;/code&gt;를 만족한다. x의 값 중 하나가 y를 참조할 경우, 객체 x를 객체 y의 부모로 정의한다. 조상(ancestor) 관계는 요소 관계 &lt;code class=&quot;highlighter-rouge&quot;&gt;E&lt;/code&gt;를 사용하여 정의한 부모 관계의 이행적 폐쇄(Transitive Closure)이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/2018-11-08-opsets/image12.png&quot; alt=&quot;image12&quot; /&gt;&lt;/p&gt;

&lt;p&gt;루트가 Parent가 없고 모든 루트가 아닌 노드가 하나의 Parent를 가지며 조상 관계에 사이클이없는 경우 객체 그래프는 트리이다. 이 트리 불변조건(invariant)을 만족하기 위해서 3.2절의 Operation 해석을 재정의한다. 실제로, Assign의 해석만 재정의하고 나머지 다섯 가지 Operation의 해석은 변경하지 않아도 된다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/2018-11-08-opsets/image1.png&quot; alt=&quot;image1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이 정의는 3.2절과 두 가지 차이점이 있다. 첫째, val이 부모 obj의 조상인 경우, Operation이 적용되지 않는데, 해당 Operation로 Tree에 순환 참조가 발생하기 때문이다. 둘째, 동일한 값 val을 참조하는 E의 기존 튜플이 제거되어 모든 루트가 아닌 노드가 정확히 하나의 부모를 가져야한다는 불변조건이 유지된다. 이 Assign Operation의 해석은 val이 트리의 기존 객체의 ID 일 때, 원자 이동을 수행하는데, 기존의 위치로부터 obj 내의 key를 변경한다. val이 기존 트리에 존재하지 않으면(방금 생성된 경우), Operation은 일반적인 Assign과 동일하게 동작한다.&lt;/p&gt;

&lt;h3 id=&quot;6-관련-작업&quot;&gt;6. 관련 작업&lt;/h3&gt;

&lt;h4 id=&quot;61-operation의-순차적-해석&quot;&gt;6.1 Operation의 순차적 해석&lt;/h4&gt;

&lt;p&gt;Operation의 전체 순서를 정하고 이를 순서대로 실행한다는 일반적 방식은 여러 컴퓨팅 영역에서 활용되었다. 예를 들어, 복제에 대한 상태 머신 접근법(state machine approach to replication), 데이터 모델링에 대한 이벤트 소싱 접근법(event sourcing approach to data modelling), 크래시 복구를 위한 로그 미리 쓰기(write-ahead logs for crash recovery), 직렬화 트랜잭션(serializable transaction) 그리고 확장 가능한 멀티 코어 데이터 구조(scalable multi core data structures)가 있다. OpSet 시스템은 (데이터가 복제되고 분산 되어 있다는) 피상적 유사성이 있지만 중요한 차이점을 갖고 있다.&lt;/p&gt;

&lt;p&gt;2.3절에서 알아본 것처럼, 많은 시스템은 특정 Operation이 실행 된 후 모든 후속 Operation이 전체 순서(total order)를 보장하며 실행되어야 한다는 제약에 의존한다. 즉, Operation 시퀀스는 append-only 로그이므로 새 Operation을 기존 Operation보다 먼저 삽입 할 필요가 없었다. 이것은 분산 시스템에서 분산 된 컨센서스(consensus)를 해결하는 것과 같은 원자적 브로드캐스트(혹은 total order 브로드캐스트) 프로토콜을 필요로 한다. 이런 유형의 프로토콜은 진행을 위해서 노드들의 쿼럼과 통신이 필요하고 완전한 비동기 상태에서는 진행할 수 없다.&lt;/p&gt;

&lt;p&gt;대조적으로, 2.2절의 순차 OpSet 해석은 임의의 순서로 OpSet에 Operation을 추가 할 수 있고 조정(coordination)없이 Operation ID를 할당하므로 원자적 브로드캐스트가 필요 없다. 이 방식의 시스템은 흔하지 않다. 가장 밀접하게 관련된 이전 연구는 타임 스탬프 순서에서 결정적으로 임시 트랜잭션을 실행한 Bayou system과 Burckhardt의 표준 충돌 해결 방법이다. OpSet 접근방식과 유사한 이 시스템들은 작은 ID로 새로운 Operation을 수신 할 때, 더 큰 ID를 가진 Operation의 실행 취소하고 다시 적용한다.&lt;/p&gt;

&lt;p&gt;이 논문의 기여(contribution)는 OpSet 접근 방식을 이용해서 리스트와 트리 같이 복잡한 복제 된 데이터 구조를 정의, 추론하고 이전 보다 일반적으로 공식화하는 것이다. RGA가 OpSet 기반 스펙을 충족하고 그림 2에서 설명한 인터리빙 예외가 없음을 증명했다.&lt;/p&gt;

&lt;p&gt;Baquero et a과 Grishchenko는 Operation 간의 인과 관계를 포착하기 위해 Operation의 부분 순서 로그를 CRDT로 표현할 것을 제안했다. OpSet 접근 방식은 식별자에 대한 전체 순서(total order)를 부분 순서(partial order)의 선형 확장으로 정의하는 변형으로 볼 수 있다.&lt;/p&gt;

&lt;h4 id=&quot;62-복제-데이터타입의-정의와-검증&quot;&gt;6.2 복제 데이터타입의 정의와 검증&lt;/h4&gt;

&lt;p&gt;공유 데이터 구조를 공동 편집하는 알고리즘은 Operational Transformation, CRDT에서 약 30 년간 활발히 연구 되었지만 알고리즘의 정확한 일관성(exact consistency property)이 다소 불명확 했다. 예를 들어, Sun et al은 표현한 세 가지 바람직한 성질, 즉 수렴(convergence), 인과 관계 보전(causality preservation), 의도 보존(intention preservation)을 비공식적 표현했다. 처음 두 속성의 정의가 명확하지는 않지만 “의도 보존”의 정의는 더 많은 해석의 여지가 있었다.&lt;/p&gt;

&lt;p&gt;(생략…)&lt;/p&gt;

&lt;h4 id=&quot;63-협업-가능한-트리-데이터타입&quot;&gt;6.3 협업 가능한 트리 데이터타입&lt;/h4&gt;

&lt;p&gt;그 동안 트리 데이터 구조의 공동 편집을 위해서 여러 CRDT와 OT 알고리즘이 제안되었지만 대부분의 경우 노드의 삽입, 삭제만 고려하고 이동 Operation은 지원하지 않았다.&lt;/p&gt;

&lt;p&gt;5장에서 설명한 것처럼 트리에서 새 위치로 특정 트리를 이동하는 Operation을 지원하면 추가로 처리해야 할 충돌이 발생한다. Ahmed Nacer et al은 구체적인 알고리즘을 제시하지 않았고 이러한 충돌을 처리하는 방법을 조사했다. Tao et al은 이동 Operation 처리중 충돌 발생시 동일한 객체가 둘 이상의 위치에 나타날 수 있도록할 것을 제안했는데, 이는 엄격하게는 DAG이며 트리가 아니다.&lt;/p&gt;

&lt;p&gt;Najafzadeh는 이동 Operation의 전제 조건이 안정적이지 않기 때문에 동시 이동 Operation을 CRDT로 안전하게 구현할 수 없다고 주장했다. Najafzadeh는 잠금장치를 사용하여 전역으로 이동 Operation을 동기화하여 그림 4와 같은 예외를 처리했지만 일부 Operation이 strong consistency 동기화가 필요하기 때문에 해당 데이터타입은 CRDT가 아니다.&lt;/p&gt;

&lt;p&gt;5장에 명시한 이동은 완전 비동기 트리 CRDT의 첫 번째 정의이고 Najafzadeh가 주장한 명백한 모순을 회피했다. Operation을 생성하는 시점에 전제 조건 &lt;code class=&quot;highlighter-rouge&quot;&gt;(val, obj) !∈ ancestor(E)&lt;/code&gt;를 평가하는 대신에 결정적 순서로 모든 Operation을 적용한다.&lt;/p&gt;

&lt;h3 id=&quot;7-결론&quot;&gt;7. 결론&lt;/h3&gt;

&lt;p&gt;이 논문은 복제 된 데이터타입의 의미론을 명시하기 위한 간단하지만 강력한 Operation Sets(OpSets)를 제안했다. OpSets 모델에서 다양하고 공통적으로 복제 가능한 데이터타입을 명시하고 Isabelle/HOL을 사용하여 형식적으로 그 속성을 추론했다. OpSets를 사용하여 기존 협업 텍스트 편집 알고리즘에서 발생하는 인터리빙 예외를 확인했고 RGA 알고리즘이 OpSets 리스트 스펙을 충족 시키는 것을 입증했다. 마지막으로 OpSet 모델을 사용하여 새로운 복제 알고리즘을 개발하는 방법에 대해 알아봤고 트리 CRDT에서 원자적 이동 Operation에 대한 스펙을 제안했다.&lt;/p&gt;

&lt;p&gt;OpSets는 일부 업데이트들이 적용된 후 복제본의 허용 상태를 정확하게 정의한 실행 가능한 스펙이다. 이 문서에서는 순차적인 OpSet 해석을 사용했다. Operation은 ID의 엄격한 오름차순으로 적용되는 이는 수렴(convergence)을 쉽게 보장하고 CRDT의 스펙, 불변조건에 대한 추론을 단순화하므로 매우 유용하다. 이와 반대로 이전 CRDT를 정의한 전통적인 접근법은 Operation이 교환법칙(commutative)을 만족해야했고 복잡성 높았다. RGA가 OpSets 리스트 스펙을 만족함을 증명할 때, 순차적 명세와 교환 적 구현 사이의 일치성을 입증했다. 이는 향후 작업을 위해서 다른 데이터타입에 대한 이 가설을 더 자세히 살펴 볼때 유용할 것이다. 특히, 5장에서는 분산 P2P 파일 시스템을 구현할 수 있으며 교환법칙을 만족한 이동 Operation을 갖는 트리 CRDT를 제안했다.&lt;/p&gt;

&lt;p&gt;이 논문에서는 순차적인 OpSet 해석에 초점을 맞추었지만, 특정 결정적(deterministic) 함수를 해석 함수 &lt;code class=&quot;highlighter-rouge&quot;&gt;[-]&lt;/code&gt;로 사용될 수 있다는 점을 주목하자. 특히 해석 함수를 데이터베이스의 쿼리로 생각해본다면 OpSet을 공유 데이터에 대한 모든 변경 사항을 처리하는 데이터베이스로 볼 수 있다. 결과로 생성 된 데이터타입은 데이터베이스의 materialized view에 해당된다. OpSet O에 새로운 Operation이 추가되면 &lt;code class=&quot;highlighter-rouge&quot;&gt;[O]&lt;/code&gt;에 해당하는 변화를 계산하는 것은 최적화 된 알고리즘이 개발 된 materialized view의 관리 문제이다. 이러한 기술을 복제 된 데이터타입에 적용 할 수 있으며 효율적인 CRDT 구현을 OpSet 기반 스펙에서 파생시킬 수 있다고 생각한다.&lt;/p&gt;

&lt;p&gt;(Appendix 생략…)&lt;/p&gt;</content><author><name></name></author><summary type="html">“OpSets: Sequential Specifications for Replicated Datatypes (Extended Version).” 공부하면서 정리한 내용 Original paper link: link</summary></entry><entry><title type="html">Paper 02. A Conflict-Free Replicated JSON Datatype. 요약</title><link href="http://localhost:4000/paper/2018/10/26/a-conflict-free-replicated-json-datatype.html" rel="alternate" type="text/html" title="Paper 02. A Conflict-Free Replicated JSON Datatype. 요약" /><published>2018-10-26T13:14:00+09:00</published><updated>2018-10-26T13:14:00+09:00</updated><id>http://localhost:4000/paper/2018/10/26/a-conflict-free-replicated-json-datatype</id><content type="html" xml:base="http://localhost:4000/paper/2018/10/26/a-conflict-free-replicated-json-datatype.html">&lt;p&gt;“A Conflict-Free Replicated JSON Datatype.” 공부하면서 정리한 내용&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Original paper link: &lt;a href=&quot;https://arxiv.org/pdf/1608.03960.pdf&quot;&gt;link&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;a-conflict-free-replicated-json-datatype&quot;&gt;A Conflict-Free Replicated JSON Datatype&lt;/h2&gt;

&lt;h3 id=&quot;요약&quot;&gt;요약&lt;/h3&gt;

&lt;p&gt;일반적으로 다양한 애플리케이션은 자신의 모델을 범용적인(general-purpose) 형식으로 모델링한다. 이 모델의 단일 복제본을 순차적으로 수정할 때에는 문제없지만, 여러 디바이스 로컬 저장소에서 각각 동시에 수정한다면, 어떤 값이 남아있어야 하는지 알기 어렵다. 이 논문은 CRDT를 이용해서 동시 수정으로 발생하는 충돌(conflict)를 자동으로 해결하는 JSON 자료구조를 제안한다. 이 자료구조에 적용된 알고리즘은 클라이언트에서 병합을 처리하고 모바일이나 열악한 네트워크 환경에도 적용 가능하다.&lt;/p&gt;

&lt;h3 id=&quot;1-도입&quot;&gt;1. 도입&lt;/h3&gt;

&lt;p&gt;모바일 사용자는 오프라인시에도 계속해서 앱 사용이 가능하고 네트워크가 복구 될 때, 사용자의 다른 장비와 자동으로 동기화 되길 원한다. 이러한 종류의 앱은 캘린더, 주소록, 메모장, 할일 목록, 패스워드 등이있다. 또 협업 도구들은 여러 사용자가 문서 수정의 지연(delay)이 작은 환경에서 동시에 동일한 문서를 수정하는 기능을 필요로 한다.&lt;/p&gt;

&lt;p&gt;이러한 애플리케이션은 보통 로컬에서 직접 수정가능 하도록 각각의 디바이스에 애플리케이션의 상태를 저장한다(optimistic replication). 종래의 접근 방식은 네트워크 환경이 열악한 경우 사용 불가능했다. 네트워크의 상태에 무관하게 애플리케이션이 항상 동작해야하는 경우, 서로 다른 장치에서 임의의 수정을 실행할 수 있어야 하며, 수정 결과로 발생하는 충돌을 해결할 수 있어야 한다.&lt;/p&gt;

&lt;p&gt;가장 간단한 방법은 “last writer wins” 정책과 같이 충돌 발생시 특정 수정을 버려서 해결하는 것이지만 데이터 손실이 발생하므로 이러한 접근 방식이 적절하지 못할 때가 있다. 다른 대안으로 사용자가 수동으로 충돌을 해결하게 하는 방법이 있지만, 귀찮고 에러가 발생하기 쉬운 문제가 있다.&lt;/p&gt;

&lt;p&gt;최근 애플리케이션들은 이 문제를 임기응변(ad-hoc)적이거나 애플리케이션 마다 자신들의 상황에 맞게 해결한다. 이 논문은 범용적인 JSON 데이터 모델로 표현 가능하고 정보 유실없이 동시 수정이 가능한 데이터타입을 제안한다. 이 접근 방식은 JSON 데이터타입에 대한 동시 수정을 자동으로 병합한다. 충돌 업데이트를 기록하기 위한 일반 메커니즘(multi-value register)를 제안한다. 이 메커니즘은 프로그램적으로 남아있는 충돌을 해결하는 일관된 기반을 제공한다.&lt;/p&gt;

&lt;h4 id=&quot;11-json-data-model&quot;&gt;1.1 JSON Data Model&lt;/h4&gt;

&lt;p&gt;JSON은 인기있는 범용 데이터 인코딩 포맷으로 다양한 데이터베이스나 웹서비스에서 사용한다. JSON에 추가로 스키마를 지정해서 제약할 수 있지만, 이 논문에서는 스키마가 없는 경우만 고려했다.&lt;/p&gt;

&lt;p&gt;JSON 문서는 다음과 같이 두 형식의 브랜치(branch) 노드를 포함한 트리다.
Map: 순서가 지정되지 않고 문자열 키로 찾을 수 있는 자식을 갖고 있는 노드. 논문에서는 키를 불변형, 값을 가변형으로 취급한다.
List: 애플리케이션에서 지정한 순서의 자식을 갖고 있는 노드. 가변적이다.&lt;/p&gt;

&lt;p&gt;브랜치 노드의 자식은 브랜치 노드 혹은 말단 노드(leaf)이다. 트리의 말단에는 기본 타입의 값(primitive value, [string, number, boolean, null])이 위치한다. 이 논문에서는 말단 노드의 값을 불변형으로 취급하고 해당 말단 노드를 수정시에 새로운 값으로 등록한다.&lt;/p&gt;

&lt;p&gt;이 모델은 애플리케이션의 다양한 상태를 표현하는데 충분하다. 예를들어 텍스트 문서는 단일 문자의 리스트로 표현할 수 있다. 3.1 절에서는 더 복잡한 JSON으로 애플리케이션의 data를 모델링하는 예제를 살펴본다.&lt;/p&gt;

&lt;h4 id=&quot;12-복제replication와-충돌-해결conflict-resolution&quot;&gt;1.2 복제(replication)와 충돌 해결(conflict resolution)&lt;/h4&gt;

&lt;p&gt;이 논문은 JSON 문서의 본제본(replica)을 여러 디바이스에 갖고 자신의 복제본을 먼저 수정하고 비동기적으로 원격 복제본에 반영하는 시스템을 대상으로 한다(optimistic replication).&lt;/p&gt;

&lt;p&gt;이 논문에서 필요로 하는 네트워크 환경은 하나의 복제본의 수정사항을 다른 모든 원격 복제본에 전달하는 네트워크를 필요로 한다. 네트워크는 임의적으로 지연되거나 순서가 뒤집히거나 중복 메시지가 발생할 수 있음을 가정한다.&lt;/p&gt;

&lt;p&gt;이 논문이 다루는 범위는 클라이언트 측에 있고 메시지를 처리하거나 변환하는 서버가 필요 없으므로 P2P 네트워크에서도 사용할 수 있다.&lt;/p&gt;

&lt;p&gt;4절에서는 서로 다른 디바이스에서 동시에 JSON 문서를 편집할 때 발생하는 충돌을 어떻게 해결하는지 다룬다. 이 논문의 디자인은 3가지 원칙을 기반으로 한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;자료구조의 모든 복제본은 자동으로 동일한 상태로 수렴한다.&lt;/li&gt;
  &lt;li&gt;사용자의 입력은 동시 수정으로 인해 유실되지 않는다.&lt;/li&gt;
  &lt;li&gt;업데이트의 모든 조합의 순열들은 동일한 상태로 수렴한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;13-이-논문의-공헌-내용&quot;&gt;1.3 이 논문의 공헌 내용&lt;/h4&gt;

&lt;p&gt;이 논문이 공헌한 점은 JSON 자료구조의 동시 수정 발생시 자동으로 충돌을 해결하는 알고리즘을 정의한 것이다. 이전에도 리스트, 맵, 레지스터와 같은 자료형이 개별적으로 제안되었으나 이 논문은 각각의 자료구조를 통합하고 어떤 네트워크 토폴로지에 사용할 수 있도록 했다.&lt;/p&gt;

&lt;p&gt;맵과 리스트의 중첩 자료구조를 구성하면 트리의 서로 다른 레벨을 동시에 수정하는 것이 가능하기 때문에 단일 자료구조에서 발생하지 않는 문제가 발생한다. 이 문제들은 3.1 절에서 다룬다. 중첩 데이터 구조는 많은 애플리케이션의 중요한 요구사항이다.&lt;/p&gt;

&lt;h3 id=&quot;2-관련-작업&quot;&gt;2. 관련 작업&lt;/h3&gt;

&lt;h4 id=&quot;21-operation-transformation&quot;&gt;2.1 Operation Transformation&lt;/h4&gt;

&lt;p&gt;OT 기반 알고리즘은 동시편집 애플리케이션에서 오랫동안 사용되었다. 이 애플리케이션들은 대부분 문자열을 원소로하는 단일 리스트를 문서로 다루며 충첩 트리 자료구조를 지원하지 않는다. XML 문서를 편집하기 위해서 OT를 일반화한 일부 알고리즘은 충첩 리스트를 다뤘으나 이 논문이 다루는 충첩 맵을 다루지는 않았다. 또 OT 알고리즘은 동시에 발생하는 오퍼레이션의 수가 증가하면 급격히 성능이 저하된다.&lt;/p&gt;

&lt;p&gt;대다수의 OT 기반의 협업 시스템(Google Docs, Etherpad, Novell Vibe, Apache Wave)은 오퍼레이션의 순서를 결정하기 위한 단일 서버를 필요로 하는데, 이 디자인 개념은 Jupiter 시스템에서 왔다. 이 접근 방식은 변환 함수를 단순화하고 오류 발생을 줄이지만 P2P에서 사용할 수 없었다.&lt;/p&gt;

&lt;p&gt;협업 작업에 사용할 많은 보안 메시징 프로토콜은 각각의 수신자가 메시지를 동일한 순서로 볼 수 없을지도 모른다. Atomic broadcast 프로토콜을 사용하면 서버 없이도 오퍼레이션의 전체 순서를 보장할 수 있지만, 합의(consensus) 프로토콜과 마찬가지로 쿼럼에 각 노드들이 접근가능할 때에만 안전하게 처리한다. 이 P2P 시스템에서의 모바일 디바이스는 자주 오프라인이 되고 atomic broadcast는 쿼럼에 접근하기 위해서 문제가 발생해서 사용하기 어려울 것이다. 쿼럼 없이 이를 처리할 수 있는 방식은 causal ordering 이다.&lt;/p&gt;

&lt;p&gt;Google Realtime API는 임의의 중첩 리스트와 맵을 OT로 구현했고 Google Docs처럼 서버를 필요로 한다. 자세한 알고리즘은 아직 발표되지 않았다.&lt;/p&gt;

&lt;h4 id=&quot;22-crdt&quot;&gt;2.2 CRDT&lt;/h4&gt;

&lt;p&gt;CRDT는 동시 편집을 지원하는 자료구조로 동시 수정의 수렴을 보장하며 데이터타입에 메타데이타를 추가해서 생성시 오퍼레이션이 교환법칙(commutative)이 가능하도록 한다. 이 논문은 CRDT JSON 데이터타입을 다룬다.&lt;/p&gt;

&lt;p&gt;CRDT를 기반으로한 레지스터(register), 카운터(counter), 맵, 셋(sets)은 Riak과 같이 다양한 출시된 시스템에서 사용된다. 순서 리스트의 알고리즘은 WOOT, RGA, Treedoc, Logoot, LSEQ등 여러가지가 제안되었지만 모두 기본형 값을 사용하고 값으로 다른 CRDT를 갖는 충첩을 지원하지는 않았다.&lt;/p&gt;

&lt;p&gt;충첩 CRDT에 대한 연구는 최근에 진행되었다. Riak은 맵안에 카운터와 레지스터, 맵의 중첩이 가능했다. (생략…) 이 연구들 모두 리스트를 중첩하지는 않았지만, 이 논문에서 사용하는 의미체계의 기초가 된다. (생략…)
레지스터, 맵, 리스트들이 수년간 개별적으로 연구되었고 이 논문은 JSON 유사한 구조의 임의의 중첩 CRDT를 제안한다.&lt;/p&gt;

&lt;h4 id=&quot;23-다른-접근-방법&quot;&gt;2.3 다른 접근 방법&lt;/h4&gt;

&lt;p&gt;복제된 데이터 시스템은 동시 수정과 충돌을 해결해야 하지만, 기존에는 이 문제를 각 애플리케이션 마다 임기응변으로 해결했다. 예를 들어, Dynamo와 CouchDB는 여러 값이 같은 키에 동시에 쓰여지면 데이터베이스는 이러한 모든 값을 보존하고 충돌 해결을 애플리케이션에서 처리하도록 한다.(생략…)&lt;/p&gt;

&lt;p&gt;충돌 해결에 자주 사용하는 또 다른 접근법은 LWW(last writer wins)로, 여러 동시 수정 중 하나를 “승자”로 선택하고 다른 기록을 삭제한다. LWW는 Apache Cassandra에서 사용된다. 동시 수정으로 인해 사용자 입력이 손실되는 단점이 있다.&lt;/p&gt;

&lt;p&gt;트리 구조에 대한 동시 편집을 해결하는 것은 파일 동기화 분야에서 연구되었다. 마지막으로 Bayou에서는  오프라인 노드가 일시적으로 트랜잭션을 실행하고 다음 온라인 상태 일 때 이를 확인하는데 동일한 일련 순서로 트랜잭션을 실행하는 모든 서버에 의존이 있고 트랜잭션이 전제 조건에 따라 성공했는지 여부를 결정한다. Bayou는 직렬화가 필요하고 CRDT를 사용하여 표현할 수 없는 유일성 제약 조건과 같은 전역 불변량을 표현할 수 있다는 장점이 있다. Bayou의 단점은 애플리케이션이 명시적으로 처리해야하는 임시 트랜잭션이 롤백 될 수 있다는 점이고 CRDT는 하나의 복제본에서 수행 된 작업이 실패하지 않는다.&lt;/p&gt;

&lt;h3 id=&quot;3-자료구조-구성&quot;&gt;3. 자료구조 구성&lt;/h3&gt;

&lt;h4 id=&quot;31-동시-편집-예&quot;&gt;3.1 동시 편집 예&lt;/h4&gt;

&lt;p&gt;JSON 자료구조를 순차적으로 편집하는 의미론은 잘 알려져 있으며, 플랫한 맵 또는 리스트의 동시 편집은 기존 논문에서 철저히 조사되었다. 그러나 JSON CRDT에서 동시성과 중첩 된 데이터 구조 간의 상호 작용으로 인해 문제가 발생한다.&lt;/p&gt;

&lt;p&gt;다음 예제는 JSON 문서가 동시에 수정 될 때 발생할 수있는 몇 가지 상황을 보여 주며, 이 논문에서 제시한 알고리즘에 의해 처리되는 방법에 대해 알아본다. 예제에서는 p와 q라는 두 개의 복제본을 가정한다.복제본의 로컬 상태는 박스에 그렸고 로컬 상태의 수정 내용은 레이블이 있는 실선 화살표로 표시한다. 시간은 아래로 흐른다. 복제본은 로컬 상태만 변경하기 때문에 복제본 간에 변경에 대해서만 통신한다. 네트워크 통신은 점선 화살표로 표현했다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/2018-10-26-a-conflict-free-replicated-json-datatype/image1.png&quot; alt=&quot;image1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;그림 1에서는 키가 “key”이고 값이 “A”을 갖은 문서에서 리플리카 p는 값을 “B”로 설정하고 리플리카 q는 동시에 “C”로 설정한다. 이후 네트워크 통신을 통해 편집 내용을 받으면 충돌을 감지한다. 문자열 “B”와 “C”를 의미있게 병합 할 수 없기 때문에 시스템은 동시에 발생한 두 업데이트를 보존해야 한다. 이 데이터 유형은 다중 값 레지스터(multi-value register)로 불린다. 복제본은 레지스터에 단일 값만 할당 할 수 있지만 읽기시에 동시에 쓰인 값의 집합이 반환된다.&lt;/p&gt;

&lt;p&gt;다중 값 레지스터는 충돌 해결을 실제로 수행하지 않으므로 인상적인 CRDT는 아니다. 이 논문에서는 자동 병합 함수가 정의되지 않은 기본형에만 이 방식을 취한다. 하지만 다른 CRDT는 이를 처리한다(예 : 카운터 CRDT 또는 공동 편집에 사용하는 정렬된 리스트 CRDT).&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/2018-10-26-a-conflict-free-replicated-json-datatype/image18.png&quot; alt=&quot;image18&quot; /&gt;&lt;/p&gt;

&lt;p&gt;그림 2에서는 JSON 트리에서 다양한 레벨에서의 동시 편집의 예를 표현했다. 여기서 리플리카 p는 colors 맵에 “red”를 추가하고 동시에 리플리카 q는 colors 맵을 지운 다음 “green”을 추가한다. 빈 맵을 할당하는 대신, q는 colors 맵의 키를 제거한 다음 해당 키에 새 값을 할당한다. 이 예제의 어려움은 트리의 하위 레벨에서 “red”를 추가하는 것과 동시에 트리의 상위 레벨에서 colors 맵이 제거된다는 점이다.&lt;/p&gt;

&lt;p&gt;레벨간 충돌을 처리하는 방법중 하나는 트리의 상위에서 발생한 편집이 항상 해당 하위 트리에서 발생한 동시 편집을 무시하는 것이다. 이 경우, “red”의 추가는 상위 삭제(blanking-out)에 의해 무시되기 때문에 버린다. 그러나 이러한 동작은 동시 수정으로 인해 사용자 입력을 잃지 않아야 한다는 초기 요구 사항을 위반한다. 따라서 논문에서는 그림 2와 같이 모든 변경 사항을 보존하는 병합 의미론을 정의했다. “blue”는 최종 맵에서 제거되어야 하며 “빨간색”과 “녹색”은 명시 적으로 추가 되었기 때문에 맵에 추가되어야 한다. 이 동작은 Riak 의 CRDT 맵의 동작과 일치한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/2018-10-26-a-conflict-free-replicated-json-datatype/image15.png&quot; alt=&quot;image15&quot; /&gt;&lt;/p&gt;

&lt;p&gt;그림 3은 동일한 키의 리스트에서 발생하는 문제점을 표현했다. 두 개의 복제본이 동시에 동일한 키에 값을 삽입했을 때, p와 q는 각각 독립적으로 동일한 맵에 “grocery”키로 리스트를 만들고 리스트에 항목을 추가한다. 그림 1의 경우, 동일한 맵 키에 대한 동시 할당은 애플리케이션에 의해 해결했지만, 그림 3에서 두 값은 리스트에서 자동으로 병합한다. 각 복제본에 삽입 된 항목의 순서와 인접성을 보존하므로 병합 결과에서 “eggs”뒤에 “ham”이 있고 “milk”뒤에 “flour”가 추가된다. 어떤 복제본의 항목이 병합 된 결과에서 처음으로 나타 나야하는지에 대한 정보는 없으므로 “eggs, ham, milk, flour”와 “milk, flour, eggs, ham”중 하나가 선택된다. 단, 모든 복제본은 동일한 순서로 병합된다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/2018-10-26-a-conflict-free-replicated-json-datatype/image10.png&quot; alt=&quot;image10&quot; /&gt;&lt;/p&gt;

&lt;p&gt;그림 4는 문서를 문자 리스트로 처리해서 협업 텍스트 편집기를 구현하는 방법을 표현했다. 병합 된 결과에  모든 변경 사항이 보존된다. “a”앞에 “y”가 삽입, “x”와 “z”는 “a”와 “c”사이에 삽입 “b”는 삭제됨.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/2018-10-26-a-conflict-free-replicated-json-datatype/image13.png&quot; alt=&quot;image13&quot; /&gt;&lt;/p&gt;

&lt;p&gt;그림 5는 그림 3처럼 두 개의 복제본이 동시에 동일한 맵 키를 삽입 했지만 다른 타입을 값으로 할당하는 문제를 표현했다. p는 중첩 맵을 삽입했고 q는 리스트를 삽입했다. 이러한 데이터 유형은 의미있게 병합할 수 없으므로 두 값을 별도로 보존한다. 이 논문은 맵의 각 키에 map, list, register 값에 대한 타입 주석(mapT, listT, regT)을 태깅해서 각 유형이 별도의 네임 스페이스를 유지하도록 했다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/2018-10-26-a-conflict-free-replicated-json-datatype/image14.png&quot; alt=&quot;image14&quot; /&gt;&lt;/p&gt;

&lt;p&gt;마지막으로, 그림 6은 모든 사용자 입력을 보존하는 원칙의 한계를 표현했다. p가 항목을 리스트에서 제거하는 동시에 q는 항목을 완료로 표시한다. 변경 사항이 병합되면 맵 키 “done”이 참인 제목이 없는 값이 남는다. 이 동작은 그림 2에서는 정상 동작하지만 여기에서는 오류를 범한다. 이 경우, 동시 갱신 중 하나를 버리고 작업 항목에 “제목”및 “완료” 필드가 있는 내재적 스키마를 보존하는 것이 더 바람직하다.&lt;/p&gt;

&lt;h4 id=&quot;32-json-vs-xml&quot;&gt;3.2 JSON vs XML&lt;/h4&gt;

&lt;p&gt;JSON의 일반적인 대안은 XML로 협업 편집은 이전에 연구되었다. XML과 JSON의 트리 구조는 매우 유사하지만 중요한 차이가 있다.&lt;/p&gt;

&lt;p&gt;JSON에는 임의의 맵과 리스트를 중첩 할 수 있는 구조를 갖고 있다. 반면 XML은 자식으로는 리스트를 갖고 attribute는 맵을 갖지만 중첩 구조를 허용하지 않는다. 따라서 XML은 리스트는 값으로 맵을 지원하지만 맵은 값으로 리스트를 지원하지 않는다. 따라서 XML은 JSON보다 표현력이 부족하다. 그림 3과 5의 시나리오는 XML에서 구현할 수 없다. 일부 애플리케이션은 XML 문서의 하위 attribute에 맵과 유사한 의미를 첨부하지만 이 구조는 XML 자체의 특성은 아다. 동일한 키를 가진 자식이 여러 개 동시에 생성되는 경우 기존 알고리즘은 그림 3과 같이 병합하지 않고 동일한 키를 가진 중복 자식을 만들어야한다.&lt;/p&gt;

&lt;h4 id=&quot;33-문서-편집-api&quot;&gt;3.3 문서 편집 API&lt;/h4&gt;

&lt;p&gt;협업 가능한 데이터 구조에 대한 의미(semantics)를 정의하기 위해 먼저 모든 복제본에서 로컬에 실행하며 해당 복제본을 쿼리하고 수정할 수 있는 간단한 명령 언어(command language)를 그림 7처럼 정의한다. 읽기 쿼리를 수행하면 부작용(side effect)이 없지만 문서를 수정하면 부작용이 발생하는 작업이 생성된다. 이러한 작업은 문서의 로컬 복사본에 즉시 적용되며 다른 복제본에 비동기(asynchronous)로 브로드 캐스팅 큐에 추가된다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/2018-10-26-a-conflict-free-replicated-json-datatype/image4.png&quot; alt=&quot;image4&quot; /&gt;&lt;/p&gt;

&lt;p&gt;명령 언어의 구문(syntax)은 그림 7에 있다. 완전한 프로그래밍 언어가 아니라 문서 상태를 쿼리하고 수정하는 API이다. 애플리케이션은 사용자 입력을 받아 API에 일련의 명령(무한한)을 발행한다. API는 일관된 병합 의미를 정의 할 수 있도록 많은 프로그래밍 언어에서 발견되는 JSON 라이브러리와 약간 다르다.&lt;/p&gt;

&lt;p&gt;먼저 공식적인 의미를 부여하기 전에 언어를 비공식적으로 설명한다. 표현식 구조 EXPR은 문서의 위치를 ​​식별하는 커서를 구성하는 데 사용된다. 표현식(expression)은 JSON 문서 트리의 루트를 식별하는 특수 토큰 doc 또는 let 명령에서 이전에 정의 된 변수 x로 시작한다. 이 표현식은 왼쪽에서 오른쪽으로 트리가 잎을 향해 잎을 향해 이동할 때 커서가 취하는 경로를 정의한다. 연산자 .get (key)는 맵에서 키를 선택하고 .idx (n)은 정렬 된 순서의 n 번째 요소를 선택한다.&lt;/p&gt;

&lt;p&gt;또한 EXPR은 문서의 상태 질의가 가능하다. keys는 현재 커서에서 맵의 키들을 반환하고, values는 현재 커서의 다중 값 레지스터의 내용을 반환한다. 명령 CMD는 로컬 변수(let)의 값을 설정하거나 네트워크 통신 (yield)을 수행해서 문서를 수정한다. 문서는 리스트에 요소를 삽입하여 레지스터(연산자 : =는 레지스터 값을 할당)에 쓰거나 (insertAfter는 커서로 식별 된 기존 요소 다음에 새 요소를 배치) 또는 리스트 또는 맵에서 요소를 삭제할 수 있다(delete는 커서로 식별 된 요소를 삭제).&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/2018-10-26-a-conflict-free-replicated-json-datatype/image3.png&quot; alt=&quot;image3&quot; /&gt;&lt;/p&gt;

&lt;p&gt;그림 8은 쇼핑리스트를 표현하는 새로운 문서를 구성하는 명령들의 예다. 먼저 문서는 빈 맵 리터럴 인 {}로 설정되고 그 맵 내의 키 “shopping”은 빈 리스트 []로 설정한다. 세 번째 행은 “shopping”키로 이동하여 리스트의 헤드(head)를 선택하여 커서를 head라는 변수에 할당한다. 리스트 요소 “eggs”가 리스트의 헤드에 삽입된다. 5 행에서 변수 egg는 리스트 요소 “eggs”를 가리키는 커서로 할당된다. 그런 다음 헤드에 “cheese”, “eggs”뒤에 “milk”라는 두 가지 요소가 삽입된다. 커서 eggs는 색인에 의해서가 아니라 ID에 의해 리스트 요소를 식별한다. “cheese” 삽입 후 요소 “eggs”은 index 1에서 2로 변경되지만 “milk”는 “eggs” 다음에 삽입된다. 나중에 보게 되겠지만, 이 기능은 동시 수정이있을 때 바람직한 의미를 얻기 위해 유용하다(Cursor).&lt;/p&gt;

&lt;h3 id=&quot;4-형식-의미론formal-semantics&quot;&gt;4. 형식 의미론(Formal Semantics)&lt;/h3&gt;

&lt;p&gt;이어서 3절에서 알아본 동시 의미론을 성취하는 방법을 형식적으로 설명한다. 리플리카 p의 상태는 유한 부분 함수(finite partial function) 인 Ap에 의해 설명된다. 명령 언어의 평가 규칙은 로컬 상태 Ap를 검사하고 수정하며 Aq(다른 리플리카 q는 p와 다름)와 의존성이 없다. 복제본 간의 유일한 통신은 yield 명령을 평가할 때 발생하는데, 이는 나중에 알아본다. 지금은 단일 복제본 p의 명령 실행에 대해 집중적으로 알아본다.&lt;/p&gt;

&lt;h4 id=&quot;41-표현식-평가expression-evaluation&quot;&gt;4.1 표현식 평가(Expression Evaluation)&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/2018-10-26-a-conflict-free-replicated-json-datatype/image19.png&quot; alt=&quot;image19&quot; /&gt;&lt;/p&gt;

&lt;p&gt;그림 9는 명령 언어에서 EXPR 표현식을 평가하는 규칙이며 로컬 복제본 상태 Ap의 컨텍스트에서 평가된다. EXEC 규칙은 명령이 순차적으로 실행된다는 가정을 공식화했다. LET 규칙은 프로그램이 로컬 상태에 추가한 로컬 변수를 정의하도록 한다(표기법 Ap [x → cur]은 Ap와 동일하지만 Ap(x) = cur을 제외한 부분 함수를 나타냄). VAR 규칙은 애플리케이션이 이전에 정의한 변수의 값을 검색 할 수 있게한다.&lt;/p&gt;

&lt;p&gt;이어지는 규칙은 표현식이 커서로 평가되는 방법을 표현했다. 이는 문서 트리의 루트에서 일부 브랜치 또는 리프 노드까지의 경로를 나타내며 JSON 문서의 특정 위치를 모호하지 않게 식별한다. 커서는 변경 불가능한 키와 식별자로만 구성되므로 네트워크를 통해 다른 복제본으로 보낼 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/2018-10-26-a-conflict-free-replicated-json-datatype/image12.png&quot; alt=&quot;image12&quot; /&gt;&lt;/p&gt;

&lt;p&gt;예를 들어, id (1)이 이 리스트를 삽입 한 작업의 고유 식별자라고 가정 할 때, cursor(mapT(doc), listT( “shopping”), id1)는 그림 8의 리스트 요소 “eggs”를 나타내는 커서이다. 요소 (4.2.1절에서 이 식별자들에 대해 알아본다). 커서는 로컬 복제본 상태 구조 Ap를 통해 경로로 해석되며 왼쪽에서 오른쪽으로 순서로 루트의 doc 맵에서 시작해서 listT 타입의 “shopping” 항목을 탐색하고 ID가 1인 식별자인 리스트 요소로 끝난다. 일반적으로, 커서(&amp;lt;k1, …, kn-1&amp;gt;, kn)는 키 k1,. . . , kn-1과 항상 존재하는 최종키(kn)으로 구성된다. kn은 벡터의 마지막 요소인데, 벡터의 다른 요소에는 traversal 되는 분기 노드의 데이터 유형으로 mapT 또는 listT 태그가 지정되는 반면 데이터 유형이 태깅되지 않는다는 점이 다르다.&lt;/p&gt;

&lt;p&gt;그림 9의 DOC 규칙은 특수 원자 doc를 사용하여 문서의 루트를 참조하는 가장 간단한 커서(hi, doc)를 정의한다. GET 규칙은 커서로 맵의 특정 키로 이동한다. 예를 들어, doc.get( “shopping”) 표현식은 DOC 및 GET 규칙을 적용하여 cursor(&amp;lt;mapT(doc)&amp;gt;, “shopping”)로 평가된다. doc.get(…) 표현식은 doc가 mapT 유형임을 암시적으로 나타낸다.&lt;/p&gt;

&lt;p&gt;규칙 IDX1…5는 .idx(n)표현식을 평가하여 커서를 리스트의 특정 요소로 이동시키는 방법을 정의한다. IDX1은 리스트의 헤드를 나타내는 커서를 구성하고 이어지는 규칙에 위임해서 리스트를 검사한다. IDX2는 커서의 키 벡터에 따라 로컬 상태를 재귀적으로 찾아낸다. 키 벡터가 비어있을 때 컨텍스트 ctx는 문제의 리스트를 저장하는 Ap의 하위 트리이며 규칙 IDX3, 4, 5는 원하는 요소가 발견 될 때까지 해당 리스트에 반복 수행한다. IDX5는 인덱스가 0에 도달하면 반복문을 종료하고 IDX3은 다음 요소로 이동하여 인덱스를 감소 시키며 IDX4는 삭제 됨으로 표시된 리스트 요소를 건너뛴다. 이 구조는 링크드리스트과 유사하다(각 리스트 요소는 고유 한 식별자 k와 k 다음에 오는 요소의 ID를 구하는 next(k) 부분 함수를 갖음).&lt;/p&gt;

&lt;p&gt;삭제된 요소는 링크드 리스트 구조에서 제거되지 않지만 삭제 된 것으로 표시하는데(tombstone) 이를 위해
요소에 대한 존재 여부를 알 수 있는 pres(k)를 유지한다. 리스트 요소가 삭제되면 pres 집합에서 제거해서 삭제로 표시한다. 그러나 리스트 요소를 참조하는 일은 동시 작업으로 인해 pres 세트가 다시 비어 있지 않게 될 수 있다(그림 2 및 6의 상황을 초래). 규칙 IDX4는 색인을 감소시키지 않고(즉, 리스트 요소로 계산하지 않음) 다음 요소로 이동한다.&lt;/p&gt;

&lt;p&gt;KEYS1, 2, 3 규칙은 애플리케이션이 맵에서 키 집합을 검사 할 수있게 한다. 이 집합은 로컬 상태를 검사하고 현재 상태 집합이 비어있는 키를 제외하여 결정된다(키가 삭제되었음을 나타냄). 마지막으로, VAL1,2,3 규칙은 IDX 규칙과 유사한 재귀적 규칙 구조를 사용하여 애플리케이션이 특정 커서 위치에서 레지스터의 내용을 읽을 수 있게한다. 레지스터는 로컬 상태의 regT 유형 주석을 사용하여 표현된다. 복제본은 레지스터에 단일 값만 할당 할 수 있지만 여러 개의 복제본이 동시에 값을 할당하면 레지스터에 여러 값이 포함될 수 있다.&lt;/p&gt;

&lt;h4 id=&quot;42-오퍼레이션-생성하기&quot;&gt;4.2 오퍼레이션 생성하기&lt;/h4&gt;

&lt;p&gt;오퍼레이션(Operation)은 문서의 상태를 명령(command)으로 변경하면 발생하는 변환(mutation)을 표현한다. 이 논문의 의미론에서, 명령은 로컬 복제 상태 Ap를 직접 수정하지 않고 오퍼레이션만 생성 한 뒤 즉시 Ap에 적용되고 동일한 오퍼레이션이 다른 복제본에도 비동기적으로 브로드캐스팅된다.&lt;/p&gt;

&lt;h4 id=&quot;421-램포트-시계lamport-timestamp&quot;&gt;4.2.1 램포트 시계(Lamport timestamp)&lt;/h4&gt;

&lt;p&gt;모든 오퍼레이션에는 로컬 상태와 커서에서 사용되는 고유 한 식별자(unique identifier)가 제공된다. 요소가 리스트에 삽입되거나 값이 레지스터에 할당 될 때마다 새 리스트 요소 또는 레지스터 값은 이를 생성한 작업의 식별자로 구분된다. 복제본 간의 동기 조정을 필요로하지 않고 전역적으로 고유한 작업 식별자를 생성하기 위해 램포트 시계를 사용한다. 램포트 시계는 Pair(c, p)이며, 여기서 p ∈ ReplicaID는 편집이 이루어진 복제본의 유일한 식별자 (예 : 공개 키의 해시)이고 c ∈ N은 저장된 카운터로 각 복제본에서 모든 작업에 대해 증가한다. 각 복제본은 엄격하게 단조(monotonically) 증가하는 카운터 값 c의 시퀀스를 생성하므로 Pair (c, p)는 고유하다. 복제본이 로컬에 저장된 카운터 값보다 큰 카운터 값 c를 갖는 연산을 수신하면 로컬 카운터는 수신 받은 카운터의 값으로 증가한다. 이렇게하면 o1가 o2보다 먼저 발생하는 경우(즉, o2를 생성 한 복제본이 o2가 생성되기 전에 o1을 받고 처리 한 경우) o2가 o1보다 큰 카운터 값을 가져야한다. 동시 작업만 동일한 카운터 값을 가질 수 있다. 램포트 시계로 오퍼레이션에 대해 전체 정렬을 할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/2018-10-26-a-conflict-free-replicated-json-datatype/image9.png&quot; alt=&quot;image9&quot; /&gt;&lt;/p&gt;

&lt;p&gt;한 작업이 다른 작업보다 먼저 발생하면 이 순서는 인과 관계와 일치한다(이전 작업의 timestamp가 더 낮음). 두 작업이 동시에 수행되는 경우 &amp;lt; 에 따른 순서는 임의적(arbitrary)이지만 결정적(deterministic)이다. 이 정렬 속성은 정렬 된 리스트의 의미론 정의에 중요하다.&lt;/p&gt;

&lt;h4 id=&quot;422-오퍼레이션-구조&quot;&gt;4.2.2 오퍼레이션 구조&lt;/h4&gt;

&lt;p&gt;오퍼레이션은 튜플로 id는 오퍼레이션을 식별하는 램포트 시계, cur는 변경의 문서 내의 위치를 ​​나타내는 커서, mut는 지정된 위치의 변환, deps는 인과 관계가 의존된 오퍼레이션의 집합이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/2018-10-26-a-conflict-free-replicated-json-datatype/image8.png&quot; alt=&quot;image8&quot; /&gt;&lt;/p&gt;

&lt;p&gt;o2가 replica p에 의해 생성 된 경우, o2의 인과 관계는 o2가 생성 된 시점에 이미 p에 적용된 모든 연산이다. 이 논문에서, 모든 인과 관계의 램포트 시계 집합으로 deps를 정의한다. 실제 구현에서는 이 집합이 비실용적으로 커지므로 인과 관계의 간략한 표현이 대신 사용된다(예 : 버전 벡터, 상태 벡터 또는 점선 버전 벡터). 그러나 의미론에서 모호성을 피하기 위해 의존성을 간단한 오퍼레이션 ID 세트로 설명한다. 인과 관계 종속성의 목적은 오퍼레이션에 부분적 순서를 부여하는 것이다. 오퍼레이션은 “이전에 발생한 모든 작업”이 적용된 후에 만 ​​적용될 수 있다. 특히 특정 복제본에서 생성된 작업 시퀀스가 ​​다른 모든 복제본에서 동일한 순서로 적용된다는 의미이다. 동시 작업(즉, 어느 방향으로도 인과 관계가없는 경우)은 임의의 순서로 적용 할 수 있다.&lt;/p&gt;

&lt;h4 id=&quot;423-오퍼레이션-의미론semantics-of-generating-operations&quot;&gt;4.2.3 오퍼레이션 의미론(Semantics of Generating Operations)&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/2018-10-26-a-conflict-free-replicated-json-datatype/image6.png&quot; alt=&quot;image6&quot; /&gt;&lt;/p&gt;

&lt;p&gt;MAKE-ASSIGN, MAKE-INSERT 및 MAKE-DELETE 규칙은 명령이 문서를 어떻게 변경시키는 지 정의한다. 셋 모두 MAKE-OP 규칙에 위임하여 작업을 생성하고 문서에 반영한다. MAKE-OP는 복제본 p에 적용된 모든 작업 ID 집합인 Ap(ops)의 기존 카운터보다 1만큼 큰 카운터 값을 선택하여 새로운 램포트 시계를 생성한다. MAKE-OP는 위에 설명 된 양식의 op() 튜플을 구성하고 APPLY-LOCAL 규칙에 위임하여 작업을 처리한다. APPLY-LOCAL은 다음 세 가지 작업을 수행한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;오퍼레이션을 평가하고 수정된 로컬 상태 Ap’를 생성&lt;/li&gt;
  &lt;li&gt;생성된 오퍼레이션 대기열 Ap(queue)에 오퍼레이션을 추가&lt;/li&gt;
  &lt;li&gt;해당 ID를 처리 된 연산 집합 Ap(ops)에 추가.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;(Burckhardt et al.에서 영감을 받은) yield 명령은 다른 복제본과의 작업 송수신 및 원격 복제본의 작업 적용하는 네트워크 통신을 수행한다. APPLY-REMOTE, SEND, RECV 및 YIELD 규칙은 yield의 의미를 정의한다.&lt;/p&gt;

&lt;p&gt;이러한 규칙 모두 네트워크의 비동기성을 모델링인 yield를 평가하는데 사용하기 때문에 비결정적(nondeterministic)이다. 하나의 복제본에서 보내는 메시지는 임의의 차후 시점에 다른 복제본에 도착하며, 메시지 순서의 보장은 없다. 네트워크에서 SEND 규칙은 APPLY-LOCAL에의해 Ap(queue)에 배치된 모든 작업을 가져 와서 송신 버퍼 Ap(send)에 추가한다. 따라서 RECV 규칙은 복제본 q의 전송 버퍼에서 작업을 수행하여 복제본 p의 수신 버퍼 Ap(recv)에 추가한다. 이것은 하나 이상의 복제본을 포함하는 유일한 규칙이며 모든 네트워크 통신에 적용 가능하다.&lt;/p&gt;

&lt;p&gt;수신 버퍼 Ap(recv)에 오퍼레이션이 추가되면 APPLY-REMOTE 규칙을 적용할 수 있다. 작업이 아직 처리되지 않았고 해당 인과 관계가 충족된다는 전제하에 APPLY-REMOTE는 APPLY-LOCAL과 같은 방식으로 오퍼레이션을 적용하고 ID를 처리 된 작업 집합 Ap(ops)에 추가한다. 실제 문서 수정은 다음 절에서 알아본다.&lt;/p&gt;

&lt;h4 id=&quot;43-오퍼레이션-적용하기&quot;&gt;4.3 오퍼레이션 적용하기&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/2018-10-26-a-conflict-free-replicated-json-datatype/image7.png&quot; alt=&quot;image7&quot; /&gt;&lt;/p&gt;

&lt;p&gt;그림 11은 오퍼레이션 op를 컨텍스트 ctx에 적용하여 업데이트 된 컨텍스트 ctx0을 생성하는 규칙을 나타낸다. 컨텍스트는 초기에 복제 상태 Ap이지만, 규칙들이 재귀적으로 반영될 때 상태의 서브 트리를 참조하기도 한다. 이 규칙들은 APPLY-LOCAL 및 APPLY-REMOTE가 문서의 상태 업데이트를 수행하는 데 사용된다.&lt;/p&gt;

&lt;p&gt;오퍼레이션 커서의 키 벡터가 비어 있지 않으면 먼저 DESCEND 규칙이 적용된다. 키에 설명한 경로를 따라 문서 트리를 재귀적으로 따라간다. 트리 노드가 로컬 복제본 상태에 이미 존재하면 CHILD-GET가 이를 찾는다. 그렇지 않으면 CHILD-MAP과 CHILD-LIST가 각각 빈 맵 또는 리스트를 생성한다.&lt;/p&gt;

&lt;p&gt;또한 DESCEND 규칙은 커서에 의해 기술 된 경로를 따라 각 트리 노드에서 ADD-ID1, 2를 호출하고, pres(k)에 오퍼레이션 ID를 추가하여 서브 트리가 이 오퍼레이션에 의해 만들어진 변환을 포함함을 나타낸다.&lt;/p&gt;

&lt;p&gt;그림 11의 나머지 규칙은 커서에 있는 키의 벡터가 비어있는 경우에 적용된다. 이는 변환이 적용되는 트리 노드의 컨텍스트로 내려갈 때 적용된다. ASSIGN 규칙은 레지스터에 기본형 값을 할당하는 것을 처리하고, EMPTY-MAP은 값이 빈 맵 리터럴 {}, EMPTY-LIST가 빈리스트 []의 할당을 처리한다. 이러한 세 가지 할당 규칙은 유사한 구조를 갖는다. 먼저 커서에서 이전 값을 지우고(다음 절에서 설명), 오퍼레이션 ID를 현재 pres 집합에 추가 한 다음 마지막으로 새 값을 로컬 상태 트리에 통합한다.&lt;/p&gt;

&lt;p&gt;INSERT1,2 규칙은 순서가 지정된 리스트에 새 요소의 삽입을 처리한다. 이 경우 커서는 list 요소 prev를 참조하고 새 요소는 리스트의 해당 위치 다음에 삽입된다. INSERT1은 링크드 리스트 구조를 조작하여 삽입을 수행한다. INSERT2는 동일한 위치에 리스트 요소를 동시에 삽입하는 다중 복제본의 경우를 처리하고 램포트 시계의 순서 관계를 사용하여 일관되게 삽입 지점을 결정한다. 논문의 삽입 처리에 대한 접근법은 RGA 알고리즘에 기반을 두고있다. 이 규칙은 모든 복제본이 동일한 상태로 수렴된다는 것을 보여준다.&lt;/p&gt;

&lt;h4 id=&quot;431-이전-상태-정리하기&quot;&gt;4.3.1 이전 상태 정리하기&lt;/h4&gt;

&lt;p&gt;할당 및 삭제 작업은 그림 2와 같이 동시에 이전 상태(덮어 쓰거나 삭제 된 값)가 지워지는 동시 수정이 손실되지 않도록 해야한다. 이 지우기 프로세스를 처리하는 규칙은 그림 12에 있다. 무언가를 지우는 효과는 동시 작업의 영향을 받지 않은 채로 현재 작업의 원인이되는 작업을 취소하여 빈 상태로 다시 설정하는 것이다.&lt;/p&gt;

&lt;p&gt;삭제 연산은 커서가 가리키는 리스트의 요소나 맵의 키에서 삭제한다. DELETE 규칙은 CLEAR-ELEM에 위임하여 이 오퍼레이션을 평가한다. 차례대로 CLEAR-ELEM은 mapT, listT 또는 regT 유형인지 여부에 관계없이 CLEAR-ANY를 사용하여 지정된 키가 있는 데이터를 지우고 중첩된 작업 ID를 포함하도록 현재 상태를 업데이트하고 deps의 기존 오퍼레이션들을 제거한다.&lt;/p&gt;

&lt;p&gt;CLEAR-ANY은 해당 키가 ctx에 나타나면 CLEAR-MAP1, CLEAR-LIST1 및 CLEAR-REG로 처리하고 키가 없는 경우 CLEAR-NONE(아무 것도 수행하지 않음)으로 처리한다.&lt;/p&gt;

&lt;p&gt;ASSIGN 규칙에 정의한 것 처럼 레지스터는 오퍼레이션 ID에서 값의 맵핑을 관리한다. CLEAR-REG는 deps에 나타나는 모든 오퍼레이션 ID(즉, 삭제 작업보다 먼저 발생 함)를 삭제하지만 deps에 표시되지 않는 모든 오퍼레이션 ID(삭제 작업과 동시에 발생하는 할당 오퍼레이션)를 유지하여 레지스터를 업데이트한다.
맵과 리스트 지우기도 비슷한 접근 방식을 취한다. 각 요소는 clearElem을 사용하여 재귀적으로 지워지고 pres 집합은 deps를 제외하도록 업데이트된다. 따라서, 정리 오퍼레이션 이전에 변경이 발생하는 모든 리스트 요소 또는 맵 항목은 빈 존재 세트로 끝날 것이므로 삭제 된 것으로 간주된다. 지우기 오퍼레이션과 동시에 수행되는 오퍼레이션을 포함하는 맵 또는 리스트 요소는 보존된다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/2018-10-26-a-conflict-free-replicated-json-datatype/image16.png&quot; alt=&quot;image16&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;44-수렴convergence&quot;&gt;4.4 수렴(Convergence)&lt;/h4&gt;

&lt;p&gt;1.2 절에서 설명한 핵심 요구 사항처럼 CRDT의 모든 복제본은 자동으로 동일한 상태로 수렴되어야한다. 이제 이 개념을 공식화하고 그림 9~12의 규칙이 이 요구 사항을 충족함에 대해 알아본다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/2018-10-26-a-conflict-free-replicated-json-datatype/image11.png&quot; alt=&quot;image11&quot; /&gt;&lt;/p&gt;

&lt;p&gt;정의 1 (유효한 실행). 유효한 실행은 일련의 복제본 {p1,. . . , pk}에서 생성한 오퍼레이션 집합으로 각 오퍼레이션은 걸리지(stuck) 않고 명령 시퀀스 &amp;lt;cmd1; … ;cmd n&amp;gt;를 축소(reduce)한다.&lt;/p&gt;

&lt;p&gt;축소(reduction)는 모든 전제 조건이 충족되는 규칙의 적용이 없으면 걸리게 된다. 예를 들어, idx(n)가 리스트의 끝을 지나 반복문 수행하면, 그림 9의 IDX3, 4 규칙은 멈추는데, 이는 n이 리스트의 삭제되지 않은 요소의 수보다 크면 발생한다. 실제 구현에서는 런타임 오류가 발생한다. 멈추지 않는 실행에 대해 유효한 실행을 제한함으로써 오퍼레이션이 실제로 존재하는 리스트 요소만 참조하도록 한다.&lt;/p&gt;

&lt;p&gt;yield 명령을 호출하지 않기 때문에(또는 yield의 비결정적 실행이 RECV 규칙을 적용하지 않기 때문에) 실행이 네트워크 통신을 절대로 수행하지 않는 것이 유효하다. 축소가 멈추는 지 여부를 결정하기 위해 복제본의 로컬 상태만 필요로 한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/2018-10-26-a-conflict-free-replicated-json-datatype/image17.png&quot; alt=&quot;image17&quot; /&gt;&lt;/p&gt;

&lt;p&gt;정의 2 (히스토리). 히스토리(history)는 APPLY-LOCAL 및 APPLY-REMOTE 규칙을 적용하여 특정 복제본 p에 적용된 순서대로 일련의 작업이다.&lt;/p&gt;

&lt;p&gt;평가 규칙은 주어진 복제본에서 한 번에 하나의 오퍼레이션을 순차적으로 적용하므로 순서가 잘 정의된다. 2개의 복제본 p, q가 동일한 오퍼레이션 집합을 적용한다고 할지라도, 즉 Ap(ops) = Aq(ops)인 경우, 그들은 상이한 순서로 임의의 동시 오퍼레이션을 적용 할 수 있다. APPLY-REMOTE의 전제 op.deps ⊆ Ap(ops)로 인해, 히스토리는 인과 관계와 일치한다. 오퍼레이션에 인과 관계가 있는 경우, 히스토리의 종속성 이후 특정 위치에 존재한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/2018-10-26-a-conflict-free-replicated-json-datatype/image2.png&quot; alt=&quot;image2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;정의 3 (문서 상태). 복제본 p의 문서 상태는 문서를 포함한 Ap의 하위 트리이다(Ap(mapT(doc)) 또는 Ap (listT(doc)) 또는 Ap(regT(doc))).&lt;/p&gt;

&lt;p&gt;Ap는 let으로 정의한 변수를 포함하는데, 이는 하나의 복제본에 대해 로컬이며 복제 된 상태의 일부가 아니다. 문서 상태의 정의는 이러한 변수를 제외한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/2018-10-26-a-conflict-free-replicated-json-datatype/image5.png&quot; alt=&quot;image5&quot; /&gt;&lt;/p&gt;

&lt;p&gt;정리. 유효한 실행에 참여한 두 개의 복제본 p와 q에 대해 Ap (ops) = Aq (ops)이면 p와 q는 동일한 문서 상태를 갖는다.&lt;/p&gt;

&lt;p&gt;이 정리는 부록에서 증명한다. 이것은 수렴의 안전성을 공식화한다. 두 개의 복제본이 동일한 순서의 오퍼레이션을 다른 순서로 처리 한 경우 동일한 상태로 수렴한다. 활성 속성(aliveness)과 함께, 모든 복제본이 결국 모든 오퍼레이션을 처리하므로 원하는 수렴 개념을 얻는디. 모든 복제본은 결국 동일한 상태로 끝난다.&lt;/p&gt;

&lt;p&gt;활성 속성은 충분히 자주 yeild를 호출하는 복제본의 가정과 공정하게 선택되는 yeild에 대한 모든 비결정적 규칙에 따라 달라진다. 이 논문에서 활성 속성을 공식화하지 않지만, 일반적으로 네트워크 중단은 유한한 기간이기 때문에 실제로는 적용될 수 있다고 주장한다.&lt;/p&gt;

&lt;h3 id=&quot;5-결론-향후-작업&quot;&gt;5. 결론, 향후 작업&lt;/h3&gt;

&lt;p&gt;이 논문에서는 JSON 데이터 모델을 사용하여 리스트, 맵 및 레지스터의 중첩 CRDT를 작성하는 방법을 설명했다. 임의로 중첩 된 리스트, 맵을 지원하며 복제본이 네트워크 통신을 기다리지 않고 데이터를 임의로 변경할 수 있다. 복제본은 비동기적 조작의 형태로 다른 복제본에 변형을 전송한다. 동시 오퍼레이션은 교환 가능(commutative)하므로 애플리케이션 별 충돌 해결 로직이 없어도 복제본이 동일한 상태로 수렴 된다.&lt;/p&gt;

&lt;p&gt;이 논문은 JSON CRDT의 형식 의미론에 중점을 두고 수학적 모델로 표현했다. 우리는 알고리즘의 실제 구현을 위해 작업 중이며 후속 작업에서 성능 특성을 보고 할 예정이다.&lt;/p&gt;

&lt;p&gt;동시 수정으로 인해 입력을 잃지 않는 원칙은 처음에는 합리적이라고 판단되었지만 그림 6에서 볼 수 있듯이 순차 프로그램에 익숙한 애플리케이션 프로그래머에게는 문제(suprising) 상태가 되기도 한다. 애플리케이션 프로그래머의 기대치를 이해하고 동시에 수정하는 경우에는 데이터 구조를 설계하기 위해서는 더 많은 작업이 필요하다. 더 복잡한 애플리케이션을 지원하려면 스키마 언어가 필요할 것이다. 스키마 언어는 숫자가 레지스터가 아닌 카운터로 취급 되어야한다는 의미와 같은 의미론적 주석이 필요할 수도 있다.&lt;/p&gt;

&lt;p&gt;이 논문에서 정의 된 CRDT는 삽입, 삭제 및 할당 작업을 지원한다. 이 외에도 이동 오퍼레이션(순서가 지정된 목록에서 요소의 순서를 변경하거나 문서의 한 위치에서 다른 위치로 하위 트리를 이동) 및 실행/취소 오퍼레이션을 지원하는 것이 유용할 것이다. 또한 데이터 구조의 무한한 확장을 막기 위해 쓰레기 수집(garbage collection, tombstone 제거)이 필요하다.&lt;/p&gt;

&lt;p&gt;향후 작업에서 이러한 누락 된 기능을 해결할 계획이다.&lt;/p&gt;

&lt;p&gt;(Appendix 생략… 어려워서…)&lt;/p&gt;</content><author><name></name></author><summary type="html">“A Conflict-Free Replicated JSON Datatype.” 공부하면서 정리한 내용 Original paper link: link</summary></entry><entry><title type="html">Paper 01. High Responsiveness for Group Editing CRDTs. 요약</title><link href="http://localhost:4000/paper/2018/09/14/high-responsiveness-for-group-editing-crdts.html" rel="alternate" type="text/html" title="Paper 01. High Responsiveness for Group Editing CRDTs. 요약" /><published>2018-09-14T10:00:00+09:00</published><updated>2018-09-14T10:00:00+09:00</updated><id>http://localhost:4000/paper/2018/09/14/high-responsiveness-for-group-editing-crdts</id><content type="html" xml:base="http://localhost:4000/paper/2018/09/14/high-responsiveness-for-group-editing-crdts.html">&lt;p&gt;“High Responsiveness for Group Editing CRDTs.” 공부하면서 정리한 내용&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Original paper link: &lt;a href=&quot;https://pages.lip6.fr/Marc.Shapiro/papers/rgasplit-group2016-11.pdf&quot;&gt;High Responsiveness for Group Editing CRDTs.&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;high-responsiveness-for-group-editing-crdts&quot;&gt;High Responsiveness for Group Editing CRDTs.&lt;/h2&gt;

&lt;h3 id=&quot;요약&quot;&gt;요약&lt;/h3&gt;

&lt;p&gt;공동 편집에는 빠른 응답성을 위해서 OT, CRDT와 같은 Optimistic Replication 알고리즘이 사용되고 있음.
보통 CRDT가 downstream(원격) 오퍼레이션을 처리할 때 빠름(CRDT: 지수 시간, OT: 제곱 시간). 하지만 CRDT는 upstream(로컬) 오퍼레이션 처리시 선형 시간 복잡도라서 응답성이 느림&lt;/p&gt;

&lt;p&gt;이 논문은 CRDT의 앞 부분에 “identifier data structure”라는 보조 데이터 타입을 제공해서 upstream 오퍼레이션 처리를 개선하는 방법을 제안함. identifier data structure는 동기화나 복제를 필요로 하지 않음.&lt;/p&gt;

&lt;p&gt;identifier data structure를 블록 단위 저장 접근 방식과 함께 사용하면 upstream 실행을 상당히 개선할 수 있음(무시해도 되는 정도의 메모리, 네트워크, downstream 실행 시간이 추가됨).&lt;/p&gt;

&lt;h3 id=&quot;1-도입&quot;&gt;1. 도입&lt;/h3&gt;

&lt;h4 id=&quot;optimistic-replication&quot;&gt;Optimistic Replication&lt;/h4&gt;

&lt;p&gt;공동 편집에는 응답성이 매우 중요하므로 네트워크 지연이나 문서의 락에 영향을 받지 않도록 모든 유저는 자신의 디바이스에 편집하는 문서의 리플리카를 갖고 있는데, 이를 Optimistic Replication이라 부른다.
사용자의 편집 오퍼레이션은 로컬 리플리카에 먼저 반영되고 원격에 있는 다른 사용자의 리플리카에 전송된다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;upstream 실행: 로컬 오퍼레이션을 처리&lt;/li&gt;
  &lt;li&gt;downstream 실행: 다른 사용자가 전송한 원격 오퍼레이션을 처리, 임의의 동시 편집도 해결 해야함&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;ot&quot;&gt;OT&lt;/h4&gt;

&lt;p&gt;OT는 upstream의 빠른 응답성으로 공동 편집에 사용되었지만, 각 리플리카의 히스토리를 재정렬하고 오퍼레이션을 변환해야 하므로 downstream의 처리 속도가 특히 분산 환경에서 매우 느림(O(N^2k), N: 오퍼레이션의 수, k: 리플리카 수).&lt;/p&gt;

&lt;h4 id=&quot;crdt&quot;&gt;CRDT&lt;/h4&gt;

&lt;p&gt;이를 해결하기 위해서 CRDT가 도입되었고 교환 법칙(commutative)의 오퍼레이션을 사용해서 downstream 실행시 리플리카의 일관성을 위해서 오퍼레이션을 별도로 변환하거나 정렬할 필요가 없다.
하지만 보통 CRDT 유형의 알고리즘은 upstream 처리시에 고유한 identifier를 생성하거나 조회되어야 하므로 upstream 처리가 느린 경향이 있다.&lt;/p&gt;

&lt;h4 id=&quot;block-wise-approach&quot;&gt;Block-wise approach&lt;/h4&gt;

&lt;p&gt;이를 개선하는 첫 제안은 문자를 하나하나 저장하지 않고 블록 단위로 저장하는 것이었는데, 고유한 identifier를 갖는 요소들이 줄어드므로 선형적인 처리시 유리했고 각 요소가 고유한 identifier와 같이 메타데이터를 갖고 있었으므로 메모리도 작게 사용했다. 하지만 블록으로 연결했다고 하지만 여전히 선형 시간의 복잡도를 갖고 있다.&lt;/p&gt;

&lt;h4 id=&quot;identifier-data-structure&quot;&gt;Identifier data structure&lt;/h4&gt;

&lt;p&gt;이 논문은 upstream 처리 시간을 상당히 개선할 수 있으며 대부분의 CRDT 알고리즘에 적용할 수 있는 Identifier data structure를 제안하는데, 이는 각 피어(peer)가 자신의 독립적인 구조를 갖고 있으므로 동기화 할 필요가 없고 동시성 이슈를 고려할 필요가 없다. Identifier data structure를 도입하면 본래의 알고리즘에 비해서 네트워크, 메모리 그리고 downstream 처리에 약간의 간접 비용이 있지만 무시할 정도다.&lt;/p&gt;

&lt;h3 id=&quot;2-배경-관련-crdt들&quot;&gt;2. 배경, 관련 CRDT들&lt;/h3&gt;

&lt;h4 id=&quot;231--woot&quot;&gt;2.3.1  WOOT&lt;/h4&gt;

&lt;p&gt;WOOT에서 identifier는 피어의 아이디와 삽입시 좌우측의 두 앨리먼트에 대한 링크로 구성된다. 결정론적 알고리즘으로 동일한 구역에서 요소들이 동일한 순서를 갖지만, 매우 복잡하고 처리 비용이 크다. 각 요소의 위치가 이웃 요소와 관계에 의해 결정되므로 완전히 삭제하기가 어려워서 tombstone을 사용한다. WOOT의 최적화 버전이 제안되었지만, downstream 처리 속도만 개선되었다.&lt;/p&gt;

&lt;h4 id=&quot;232-treedoc&quot;&gt;2.3.2 TreeDoc&lt;/h4&gt;

&lt;p&gt;요소의 비균형 이진 탐색트리로 요소의 identifier는 트리에서의 Path이다. 이진탐색이 가능하지만, 트리가 비균형이므로 문서의 끝에 계속해서 텍스트를 입력할 경우, 균형이 깨져서 고비용이 발생한다. 모든 피어에서 트리의 모양이 동일하며, 균형을 맞추려면 모든 피어를 동기화 해야하므로 균형을 잡는 것은 불가능하다. tombstone을 사용하지만, 특정 조건에서 제거가 가능하다.&lt;/p&gt;

&lt;h4 id=&quot;233-logoot&quot;&gt;2.3.3 Logoot&lt;/h4&gt;

&lt;p&gt;어휘 순서를 사용해서 문서의 요소의 순서를 잡는다. identifier는 3개의 정수형 튜플(1: 우선순위, 2: Upstream 피어 ID, 3: Upstream 논리 시계)의 리스트다. identifier는 배열에 저장되며, 새로운 요소 삽입을 위해서는 배열의 shift가 발생한다. (생략)&lt;/p&gt;

&lt;h4 id=&quot;234-logootsplit&quot;&gt;2.3.4 LogootSplit&lt;/h4&gt;

&lt;p&gt;Logoot의 블록버전 (생략)&lt;/p&gt;

&lt;h4 id=&quot;235-rga&quot;&gt;2.3.5 RGA&lt;/h4&gt;

&lt;p&gt;RGA는 문서에서 모든 요소는 특정 요소 뒤에 추가된다는 점을 이용한다. RGA 자료구조는 링크드 리스트로 각 요소는 내용과 다음 요소의 링크, tombstone으로 구성된다. identifier는 피어 ID, sum(삽입중 upstream 벡터 시계의 합)으로 구성된다. identifier의 순서는 피어 ID와 sum으로 판단된다.&lt;/p&gt;

&lt;h4 id=&quot;24-요약&quot;&gt;2.4 요약&lt;/h4&gt;

&lt;p&gt;빠른 반응성을 위해서 upstream에서 로그 시간 복잡도가 필요하지만, 이전 알고리즘은 이를 제공하지 못했다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;OT는 TTF tombstone&lt;/li&gt;
  &lt;li&gt;RGA와 WOOT는 tombstone&lt;/li&gt;
  &lt;li&gt;Logoot는 자체 배열을 shift해야 했으며, LogootSplit은 identifier를 관리해야 함&lt;/li&gt;
  &lt;li&gt;Treedoc은 불균형 트리를 탐색해야 함&lt;/li&gt;
  &lt;li&gt;Block 접근방식은 블록 크기에 의존적&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;사용성에 직결되는 upstream 실행시간은 매우 중요했다. RGA는 downstream 실행이 매우 우수했다.&lt;/p&gt;

&lt;h3 id=&quot;3-identifier-자료구조&quot;&gt;3. Identifier 자료구조&lt;/h3&gt;

&lt;p&gt;이 논문에서는 각 피어마다 본 알고리즘에 영향도가 작은 Identifier 자료구조를 제안한다. upstream 실행시간을 로그시간으로 수행한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/2018-09-14-high-responsiven/fe21ad0c-b50e-11e8-90df-507ecf589d46&quot; alt=&quot;screen shot 2018-09-07 at 2 27 56 pm&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;스텝 1: 사용자 액션&lt;/li&gt;
  &lt;li&gt;스텝 2: 사용자의 액션으로부터 Identifier 자료구조를 사용해서 Node를 조회&lt;/li&gt;
  &lt;li&gt;스텝 3-5: 본 알고리즘과 동일한 복제 과정&lt;/li&gt;
  &lt;li&gt;스텝 6-7: 원격 오퍼레이션을 받아서 로컬 Identifier 자료구조를 업데이트&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;idNode는 Node를 참조를 갖고 있고 반대로 Node는 idNode의 참조를 갖고 있다.&lt;/p&gt;

&lt;h4 id=&quot;31-crdt-identifier를-조회하기&quot;&gt;3.1 CRDT identifier를 조회하기&lt;/h4&gt;

&lt;p&gt;RGA와 WOOT, LogooSplit에서 문서의 노드를 조회할 때 시작작 노드부터 찾는 위치의 노드를 만날때 까지 선형탐색 한다(O(N)).&lt;/p&gt;

&lt;p&gt;Identifier 자료구조는 사용자의 수정 위치를 입력받아서 CRDT identifier를 빠르게 찾는 역할을 한다. Identifier가 순서를 갖고 있다면, Identifier 자료구조는 스킵 리스트와 같은 SortedMap이거나 혹은 weighted binary tree가 될 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/2018-09-14-high-responsiven/10a1c958-b50f-11e8-8df6-283fcd58f2b2&quot; alt=&quot;screen shot 2018-09-10 at 9 13 35 am&quot; /&gt;&lt;/p&gt;

&lt;p&gt;RGA에 identifier 자료구조(weighted tree)를 적용할 경우&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;idNode: 레퍼런스(left child, right child, parent)와 weight(하위 트리의 전체 크기), RGA 노드의 참조&lt;/li&gt;
  &lt;li&gt;RGA Node: 기본 (identifier, 내용, next 레퍼런스, tombstone)에 idNode의 참조 추가&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/2018-09-14-high-responsiven/1fe8bebc-b50f-11e8-898d-d41ef1e3d80f&quot; alt=&quot;screen shot 2018-09-10 at 9 23 01 am&quot; /&gt;&lt;/p&gt;

&lt;p&gt;사용자의 위치(pos)로 부터 특정 Node를 찾을 때, weight를 비교하면서 identifier를 검색&lt;/p&gt;

&lt;h4 id=&quot;32-downstream-에서-identifier-자료구조-업데이트하기&quot;&gt;3.2 downstream 에서 identifier 자료구조 업데이트하기&lt;/h4&gt;

&lt;p&gt;RGA에서 삽입 오퍼레이션에는 대상 노드의 identifier와 새로운 값이 포함되어 있다. 이 논문에서는 downstream에서 RGA의 기본 알고리즘으로 대상 노드가 찾아진 뒤에 identifier 자료구조를 업데이트 한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/2018-09-14-high-responsiven/2c41abd8-b50f-11e8-8d4c-508c65dc57ad&quot; alt=&quot;screen shot 2018-09-10 at 9 38 08 am&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Identifier 자료구조는 tombstone 노드를 포함하지 않으므로 deletion에는 아무처리를 하지 않고 insertion의 경우 아래와 같은 로직을 수행한다.&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;(XXX: 삭제시에도 대상 idNode를 삭제하고 weight를 업데이트 해야한다).&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/2018-09-14-high-responsiven/38e1c12a-b50f-11e8-9473-421d9ffc3083&quot; alt=&quot;screen shot 2018-09-10 at 9 51 54 am&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;33-identifier-자료구조-logoot에-적용&quot;&gt;3.3 identifier 자료구조 Logoot에 적용&lt;/h4&gt;
&lt;p&gt;(생략)&lt;/p&gt;

&lt;h3 id=&quot;4-rgatreesplit-rga--블록화--identifier-자료구조&quot;&gt;4. RGATreeSplit: RGA + 블록화 + identifier 자료구조&lt;/h3&gt;

&lt;p&gt;논문에서는 RGA가 downstream 실행에 가장 효율적인 알고리즘이고 블록 알고리즘을 적용하면, upstream과 downstream 실행을 모두 개선하므로 identifier 자료구조를 포함한 RGATreeSplit을 제안함.&lt;/p&gt;

&lt;h4 id=&quot;41-block-wise-rga-rga--블록화&quot;&gt;4.1 block-wise RGA: RGA + 블록화&lt;/h4&gt;

&lt;p&gt;이 논문에서는 block-wise RGA에는 “W. Yu. A string-wise CRDT for group editing.”에서 제안한 split과 offset 개념을 추가했다.&lt;/p&gt;

&lt;p&gt;각 노드는 다음 속성을 갖고 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;content: 메모리 효율을 위해서 tombstone화 되면, 제거 될 수 있다.&lt;/li&gt;
  &lt;li&gt;identifier: 기존 RGA identifier&lt;/li&gt;
  &lt;li&gt;nextLink: 기존 RGA의 다음 노드의 참조&lt;/li&gt;
  &lt;li&gt;offset: 사용자가 삽입한 본 위치&lt;/li&gt;
  &lt;li&gt;splitLink: split시에 다음 노드의 참조&lt;/li&gt;
  &lt;li&gt;length: 본문의 크기&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;offset x에 있는 노드를 pos로 split하면, 첫 노드의 offset은 x, 두 번째 노드의 offset은 x + pos&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/2018-09-14-high-responsiven/46c07a70-b50f-11e8-8165-7658b7743483&quot; alt=&quot;screen shot 2018-09-10 at 10 07 34 am&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;리플리카 1에서 사용자가 “ABCDEF” 삽입, identifier 는 [[1, 0], 0]&lt;/li&gt;
  &lt;li&gt;리플리카 2에서 “ABCDEF”를 전달받고 사용자가 “XY”를 pos 3에 추가, identifier 는 [[2, 1], 0]
 “ABCDEF” 블록은 “ABC”, identifier [[1, 0], 0]와 “DEF”, identifier [[1, 0], 3]로 쪼개짐&lt;/li&gt;
  &lt;li&gt;리플리카 2에서 “56789”를 마지막에 삽입 identifier는 [[2, 2], 0]&lt;/li&gt;
  &lt;li&gt;리플리카 2에서 “78” 삭제 “56789” 블록은 (“56” identifier [[2,2],0])과 (tombstone, identifier [[2, 2], 2])그리고 (“9” identifier [[2, 2], 4])로 쪼개짐.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;FINDOFFSET: identifier와 offset을 입력받아서 특정 node를 찾는 함수&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/2018-09-14-high-responsiven/508ff13e-b50f-11e8-9f91-3d5ebd6e3b84&quot; alt=&quot;screen shot 2018-09-10 at 10 23 17 am&quot; /&gt;&lt;/p&gt;

&lt;p&gt;splitLink는 identifier와 offset을 기준으로 특정 노드를 찾을 때, 성능을 위해 사용함.&lt;/p&gt;

&lt;h4 id=&quot;42-rgatreesplit의-identifier-자료구조&quot;&gt;4.2 RGATreeSplit의 identifier 자료구조&lt;/h4&gt;

&lt;p&gt;기본적으로 3절과 비슷하지만, 몇 가지 차이가 있음&lt;/p&gt;

&lt;p&gt;첫째. Identifier 자료구조와 findPosInIdentifierTree 함수의 weight에 블록 content의 크기를 반영한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/2018-09-14-high-responsiven/5b4de342-b50f-11e8-890b-ed6046b935e7&quot; alt=&quot;screen shot 2018-09-10 at 10 31 21 am&quot; /&gt;&lt;/p&gt;

&lt;p&gt;둘째. 오퍼레이션 반영시에 대상 노드를 분할해야 한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/2018-09-14-high-responsiven/6855f8c2-b50f-11e8-83c1-2a30ab65a931&quot; alt=&quot;screen shot 2018-09-10 at 1 37 57 pm&quot; /&gt;&lt;/p&gt;

&lt;p&gt;삽입 오퍼레이션은 3개(2개: 기존 노드 split, 1개: 새로운 노드)의 새로운 블록을 만들어야한다. 간단한 방법은 기존 노드를 새로운 노드의 값으로 치환하고 새로운 노드 좌측(insertBefore))과 우측(insertAfter)에 2개의 split 노드를 삽입하는 방법이다.&lt;/p&gt;

&lt;h3 id=&quot;5-평가와-실험&quot;&gt;5. 평가와 실험&lt;/h3&gt;
&lt;h4 id=&quot;51-구현&quot;&gt;5.1 구현&lt;/h4&gt;

&lt;p&gt;3절의 identifier 자료구조로 Binary weighted tree를 도입하는 경우 balanced 혹은 unbalanced(주기적 balance)의 두가지 구현 방식이 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;RGA, Logoot: TreeList(AVL 기반), 단순한 구현위해 downstream에도 별도 hashtable 없이 TreeList로 찾음&lt;/li&gt;
  &lt;li&gt;RGATreeSplit: weighted unbalanced binary tree(주기적으로 리밸런싱 수행), 리밸런싱 처리도중 응답성이 떨어질 수 있으므로 사용자가 편집을 잠시 쉬는 동안 실행 권장(실험용 구현이라 그냥 이렇게 함…)&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;52-실험&quot;&gt;5.2 실험&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;노드: Intel Xeon X3440 processors (2.53GHz), 16GB of RAM, Wheezy-x64-big-1.0 operating systems on Debian. 싱글 쓰레드.&lt;/li&gt;
  &lt;li&gt;입력: 사용자 수정 오퍼레이션을 무작위로 생성했으며, 모든 알고리즘에 대해 동일한 세트 사용&lt;/li&gt;
  &lt;li&gt;오퍼레이션의 수와 순서가 서로 다른 여섯 개의 실험(5000, 10000, 15000, 20000, 30000 및 40000개)
    &lt;h4 id=&quot;53-싱글-엘리먼트-시리즈&quot;&gt;5.3 싱글 엘리먼트 시리즈&lt;/h4&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/2018-09-14-high-responsiven/72babc58-b50f-11e8-9eab-45bf8b0457ce&quot; alt=&quot;screen shot 2018-09-10 at 3 03 25 pm&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/2018-09-14-high-responsiven/7a1e946a-b50f-11e8-8ad9-3d8723fcf8a5&quot; alt=&quot;screen shot 2018-09-10 at 3 03 49 pm&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;입력 오퍼레이션 특징: 한 요소에만 영향을 주는 수정&lt;/li&gt;
  &lt;li&gt;RGA와 RGASplit 성능이 비슷, RGATreeList와 RGATreeSplit도 성능이 비슷&lt;/li&gt;
  &lt;li&gt;예상한 대로 identifier 자료구조를 사용한 경우 upstream에서 매우 성능이 빨라짐&lt;/li&gt;
  &lt;li&gt;downstream에서 identifier 자료구조 + RGA는 성능이 소폭 하락(identifier 자료구조 업데이트 해야 하므로)&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;54-블록-시리즈-수정&quot;&gt;5.4 블록 시리즈 수정&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/2018-09-14-high-responsiven/8538104c-b50f-11e8-867e-423ebea739ac&quot; alt=&quot;screen shot 2018-09-10 at 2 05 38 pm&quot; /&gt;
&lt;img src=&quot;/assets/img/2018-09-14-high-responsiven/8d6678bc-b50f-11e8-8c69-5bec9f3f5764&quot; alt=&quot;screen shot 2018-09-10 at 3 12 39 pm&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;입력 오퍼레이션 특징: 80% 한 요소 수정과 20% 블록 수정, 블록의 평균 길이 20개&lt;/li&gt;
  &lt;li&gt;블록 기반 알고리즘이 기본 알고리즘보다 upstream과 downstream 모두에서 성능이 향상되었지만 빠른 응답을 위해 충분하지 않음&lt;/li&gt;
  &lt;li&gt;RGASplit은 시간이 지남에 따라 성능이 저하 됨.&lt;/li&gt;
  &lt;li&gt;LogootSplitAVL, TreeDoc은 원래의 RGA 알고리즘보다 다운 스트림 성능이 떨어짐&lt;/li&gt;
  &lt;li&gt;RGATreeSplit은 전반적인 성능이 가장 좋음&lt;/li&gt;
  &lt;li&gt;LogootTree는 RGATreeSplit보다 성능이 떨어지지만 블록 관리가 없어도 LogootSplitAVL과 유사한 성능 보임&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;6-결론&quot;&gt;6. 결론&lt;/h3&gt;

&lt;p&gt;이 논문에서는 CRDT 알고리즘의 응답성을 향상 시키기 위해서 블록 단위 알고리즘과 log 시간 복잡도를 위한 추가 identifier 자료구조를 제안한다. 특히, 사용자의 수정 사항을 반영하는 upstream 을 크게 개선되므로 체감 속도를 크게 향상된다.&lt;/p&gt;</content><author><name></name></author><summary type="html">“High Responsiveness for Group Editing CRDTs.” 공부하면서 정리한 내용 Original paper link: High Responsiveness for Group Editing CRDTs.</summary></entry><entry><title type="html">Idea 06. Talk is cheap. Show me the code.</title><link href="http://localhost:4000/idea/2017/08/29/talk-is-cheap-show-me-the-code.html" rel="alternate" type="text/html" title="Idea 06. Talk is cheap. Show me the code." /><published>2017-08-29T21:04:00+09:00</published><updated>2017-08-29T21:04:00+09:00</updated><id>http://localhost:4000/idea/2017/08/29/talk-is-cheap-show-me-the-code</id><content type="html" xml:base="http://localhost:4000/idea/2017/08/29/talk-is-cheap-show-me-the-code.html">&lt;blockquote&gt;
  &lt;p&gt;“Talk is cheap. Show me the code.” from Linus Torvalds&lt;/p&gt;
&lt;/blockquote&gt;</content><author><name></name></author><summary type="html">“Talk is cheap. Show me the code.” from Linus Torvalds</summary></entry><entry><title type="html">Idea 05. 디자인 태도</title><link href="http://localhost:4000/idea/2011/12/17/design-attitude.html" rel="alternate" type="text/html" title="Idea 05. 디자인 태도" /><published>2011-12-17T11:31:00+09:00</published><updated>2011-12-17T11:31:00+09:00</updated><id>http://localhost:4000/idea/2011/12/17/design-attitude</id><content type="html" xml:base="http://localhost:4000/idea/2011/12/17/design-attitude.html">&lt;p&gt;좋은 디자인으로 변경하자고 제안할 때 “이미 돌아가는 것을 왜 바꾸느냐?” 혹은 “이것은 예전에 합의한 것인데 왜 바꾸느냐?” 라는 이야기를 듣는 경우가 종종 있다.&lt;/p&gt;

&lt;p&gt;바꾸는 가장 큰 이유는 현재의 나쁜 아이디어를 고수하는 것은 가능성을 잃어버리게 하기 때문이다. 문제는 나쁜 아이디어를 만든 것보다 그것을 고수하는 것에 있다. 이것은 우리의 발목을 잡는다. 이런 집착은 탐색을 지속하며 더 나은 것을 찾기 어렵게 한다. 더 좋은 아이디어가 발견 될때 자신의 어설픈 아이디어가 옳았다는 것을 증명하거나 방어하는 것에 시간과 힘을 쓰지 말고 더 나은 아이디어를 선택할 수 있는 용기가 필요하다.&lt;/p&gt;

&lt;p&gt;우리는 중요한 사안을 너무 쉽게 결정하고 그것에 매몰되는 것은 아닌지 생각해봐야한다. 우리가 믿었던 최소 단위 원자도 쪼개지는 마당에 변경 불가능한 아이디어는 없다. 모든 아이디어는 더 나은 아이디어가 발견 될때까지 사용한다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;‘디자인 태도’란 어설픈 아이디어를 솎아내고 최후의 좋은 아이디어들을 고를 때까지 여러 가능성을 생각해보고 방향이 잡힐때까지는 ‘모든 것을 뒤집어 고려할 수 있는 의지’를 포함한다. - 비즈니스 모델의 탄생 중&lt;/p&gt;
&lt;/blockquote&gt;</content><author><name></name></author><summary type="html">좋은 디자인으로 변경하자고 제안할 때 “이미 돌아가는 것을 왜 바꾸느냐?” 혹은 “이것은 예전에 합의한 것인데 왜 바꾸느냐?” 라는 이야기를 듣는 경우가 종종 있다.</summary></entry><entry><title type="html">Idea 04. 소프트웨어 품질과 개발문화</title><link href="http://localhost:4000/idea/2011/11/28/quality_and_culture.html" rel="alternate" type="text/html" title="Idea 04. 소프트웨어 품질과 개발문화" /><published>2011-11-28T18:34:00+09:00</published><updated>2011-11-28T18:34:00+09:00</updated><id>http://localhost:4000/idea/2011/11/28/quality_and_culture</id><content type="html" xml:base="http://localhost:4000/idea/2011/11/28/quality_and_culture.html">&lt;p&gt;나와 팀은 지난 몇몇 프로젝트를 진행하는 중 소프트웨어의 품질이 개발팀의 건전한 개발문화를 통해 향상된다고 믿게 되었다. 우리가 발견하고 적용한 건전한 개발문화란 어떤 것이 있을까?&lt;/p&gt;

&lt;p&gt;첫번째. 소스코드 공동 소유다.&lt;/p&gt;

&lt;p&gt;소스코드는 개인의 소유가 아닌 팀의 공동 소유물이다. 이는 팀원들의 솔직한 커뮤니케이션 통해 이루어질 수 있다.&lt;/p&gt;

&lt;p&gt;소스코드나 일감이 개인의 소유일 경우 개인은 자신의 탑을 쌓을 확률이 높아진다. (여기서 말하는 탑은 혼자만 고칠 수 있는 코드 혹은 잘못되었지만 그 사실을 숨기고 있고 남에게 보여주기 싫은 코드,… 등이 있다.) 이런 상황에서 개발자는 메니저에게 비이상적인 개발일정을 보고하기도하고 특정한 변경이 불가능하다고 자신의 구조를 방어하기도 한다.&lt;/p&gt;

&lt;p&gt;팀이 소스코드를 공동 소유물로 여긴다면 소스코드는 더욱 건전해지고 개개인들이 만드는 기능 사이에 중복기능을 구현할 확률도 줄일 수 있다.&lt;/p&gt;

&lt;p&gt;특히 어려운 문제의 알고리즘이나 프로그램 전체의 아키텍쳐에 대해서는 상호 리뷰 혹은 짝프로그래밍이 필수 이다. 여기서 팀은 어려운 문제를 개인에게 맡기지 않고 팀의 문제로 가져간다. 주로 짝프로그래밍을 활용하는데 개인이 내리기 힘든의사 결정을 최소 두 명이상이 고민하여 결정하도록 한다. 혼자 A가 좋을까 B가 좋을까 생각하지 않고 토론을 통해서 A혹은 B를 결정한다. 역시 혼자 진행하는 것에 비해 빠른 의사 결정이 이루어진다.&lt;/p&gt;

&lt;p&gt;팀원들은 상대방의 코드를 활발하게 리딩해야한다. 이때 팀의 커뮤니케이션이 소스코드를 통해서 이루어지기도 한다. 상대방의 코드를 탐색하고 잘못된 부분에 이의를 제기해야하고 서로 이야기한 결과 잘못되었으면 과감히 수정하거나 삭제해야한다. 여기서 작성자는 자신의 코드가 지워진다는 생각은 내려놔야 한다. 코드는 팀의 소유물이니까…&lt;/p&gt;

&lt;p&gt;공동 소유가 제대로 적용된 결과로는 마치 한명이 짠 것과 같은 코딩 스타일과 프로그램 구조가 나오게 된다.&lt;/p&gt;

&lt;p&gt;두번째. 팀 학습&lt;/p&gt;

&lt;p&gt;두번째 말하고자 하는 건전한 개발 문화는 바로 팀 학습이다.&lt;/p&gt;

&lt;p&gt;팀원 중 한 사람이 새로운 프로그래밍 패러다임이나 프레임워크에 대해 공부를 한다. 그리고 자기가 알게된 내용을 팀에 전파한다. 이는 자체 세미나를 통해서 전파되기도 하고 짝프로그래밍을 통해서 전파되기도 한다. 개인 모두가 새로운 주제에 대해서 각자 공부하는 것이 아니고 관심깊게 본 다른 사람을 통해 배운다.&lt;/p&gt;

&lt;p&gt;나의 경험으로는 팀원 중 한 사람이 Functional Programming을 공부하고 리스트 처리에 대한 프레임워크를 만들어서 다른 팀원들이 좀 더 비즈니스 로직에 집중 할수 있게 도왔던적이 있다. 그 결과 개발팀은 개발 속도가 향상시킬 수 있었고 전체 소스코드의 양 또한 줄일 수 있었다.&lt;/p&gt;

&lt;p&gt;학습의 주제가 꼭 기술적인 것일 필요는 없다. 팀의 프로젝트를 도울 수 있는 어떤 것이든 상관이 없다. 예) 플레닝 포커, …&lt;/p&gt;

&lt;p&gt;건전한 개발문화를 통해 발전된 팀은 개개인의 능력도 뛰어나고 전체적으로 볼때는 한몸처럼 움직일 것이다.&lt;/p&gt;</content><author><name></name></author><summary type="html">나와 팀은 지난 몇몇 프로젝트를 진행하는 중 소프트웨어의 품질이 개발팀의 건전한 개발문화를 통해 향상된다고 믿게 되었다. 우리가 발견하고 적용한 건전한 개발문화란 어떤 것이 있을까?</summary></entry><entry><title type="html">Idea 03. 증상만 치료하지 말고, 원인을 제거하라.</title><link href="http://localhost:4000/idea/2011/11/14/eliminate-cause.html" rel="alternate" type="text/html" title="Idea 03. 증상만 치료하지 말고, 원인을 제거하라." /><published>2011-11-14T23:09:00+09:00</published><updated>2011-11-14T23:09:00+09:00</updated><id>http://localhost:4000/idea/2011/11/14/eliminate-cause</id><content type="html" xml:base="http://localhost:4000/idea/2011/11/14/eliminate-cause.html">&lt;blockquote&gt;
  &lt;p&gt;엔토니 로빈스(anthoy Robbins)는 그의 책 [내 안의 거인을 일깨우자]에서 어떤 의사의 이야기를 하고 있다. 한 의사가 물살이 빠른 강의 제방에 서 있다가, 물에 떠내려가며 살려 달라고 외치는 비명소리를 들었다. 자기 이외에는 도와줄 사람이 없다는 것을 안 그 의사는, 주저하지 않고 물 속으로 뛰어들었다. 물에 빠진 사람을 강가로 끌어 낸 뒤, 의사는, 주저하지 않고 물 속으로 뛰어들었다. 물에 빠진 사람을 강가로 끌어 낸 뒤, 의사는 인공 호흡으로 그를 소생시키려 했다. 그런데 그가 소생되기도 전에, 강에서 두 사람의 비명 소리가 들려왔다. 의사가 두 사람을 구조하여 소생시키기 무섭게, 강에서는 또다시 네사람의 비명소리가 들려 왔다. 이어서, 여덟명의 비명이 들려 왔다… 안타깝게도, 이 의사는 사람들을 구조하기에 너무 바쁜 나머지, 상류로 올라가서 도대체 누가 사람들을 물에 빠뜨리는가 찾아 볼 시간이 없었다.&lt;/p&gt;

  &lt;p&gt;Writing Solid Code P. 273 증상만 치료하는 의사
증상만 치료하지 말고, 원인을 제거하라.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;프로젝트를 진행하다 보면 개발 경험이 풍부한 개발자 임에도 불구하고 이런 실수를 저지르는 것을 자주 목격한다.&lt;/p&gt;

&lt;p&gt;계속 발전 하고 싶으면 원인을 제거하라고 말하고 싶다.&lt;/p&gt;</content><author><name></name></author><summary type="html">엔토니 로빈스(anthoy Robbins)는 그의 책 [내 안의 거인을 일깨우자]에서 어떤 의사의 이야기를 하고 있다. 한 의사가 물살이 빠른 강의 제방에 서 있다가, 물에 떠내려가며 살려 달라고 외치는 비명소리를 들었다. 자기 이외에는 도와줄 사람이 없다는 것을 안 그 의사는, 주저하지 않고 물 속으로 뛰어들었다. 물에 빠진 사람을 강가로 끌어 낸 뒤, 의사는, 주저하지 않고 물 속으로 뛰어들었다. 물에 빠진 사람을 강가로 끌어 낸 뒤, 의사는 인공 호흡으로 그를 소생시키려 했다. 그런데 그가 소생되기도 전에, 강에서 두 사람의 비명 소리가 들려왔다. 의사가 두 사람을 구조하여 소생시키기 무섭게, 강에서는 또다시 네사람의 비명소리가 들려 왔다. 이어서, 여덟명의 비명이 들려 왔다… 안타깝게도, 이 의사는 사람들을 구조하기에 너무 바쁜 나머지, 상류로 올라가서 도대체 누가 사람들을 물에 빠뜨리는가 찾아 볼 시간이 없었다. Writing Solid Code P. 273 증상만 치료하는 의사 증상만 치료하지 말고, 원인을 제거하라.</summary></entry><entry><title type="html">Idea 02. 소프트웨어, 건축물과 정원</title><link href="http://localhost:4000/idea/2011/09/28/brida.html" rel="alternate" type="text/html" title="Idea 02. 소프트웨어, 건축물과 정원" /><published>2011-09-28T03:58:00+09:00</published><updated>2011-09-28T03:58:00+09:00</updated><id>http://localhost:4000/idea/2011/09/28/brida</id><content type="html" xml:base="http://localhost:4000/idea/2011/09/28/brida.html">&lt;p&gt;파울로 코엘료의 “브리다” 의 들어가는 말에 아래와 같은 글이 적혀 있다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;건물을 세우는 사람들은 그 일에 몇 년이라는 세월을 바치기도 하지만, 결국 언젠가는 그 일을 끝내게 됩니다. 그리고 그 일을 마치는 순간, 그는 자신이 쌓아올린 벽 안에 갇히게 됩니다. 건물을 세우는 일이 끝나면, 그 삶은 의미를 잃게 되는 것입니다.
하지만 정원을 일구는 사람들도 있습니다. 그들은 몰아치는 폭풍우와 끊임없이 변화하는 계절에 맞서 늘 고생하고 쉴 틈이 없습니다. 하지만 건물과는 달리 정원은 결코 성장을 멈추지 않습니다. 또한 정원은 그것을 일구는 사람의 관심을 요구하는 동시에 그의 삶에 위대한 모험이 함께할 수 있도록 해 줍니다. 정원을 일구는 사람들은 서로를 알아봅니다. 그들은 알고 있기 때문입니다. 식물 한 포기 한 포기의 역사 속에 온 세상의 성장이 깃들어 있음을…&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;이것을 읽고 소프트웨어 생각이나는 것은 왜 일까?
지속적인 성장을 하는 소프트웨어와 그렇지 않은 소프트웨어를 보았기 때문이다.&lt;/p&gt;</content><author><name></name></author><summary type="html">파울로 코엘료의 “브리다” 의 들어가는 말에 아래와 같은 글이 적혀 있다.</summary></entry><entry><title type="html">Idea 01. 토끼굴 속으로</title><link href="http://localhost:4000/idea/2011/04/25/down-the-rabbit-hole.html" rel="alternate" type="text/html" title="Idea 01. 토끼굴 속으로" /><published>2011-04-25T21:15:00+09:00</published><updated>2011-04-25T21:15:00+09:00</updated><id>http://localhost:4000/idea/2011/04/25/down-the-rabbit-hole</id><content type="html" xml:base="http://localhost:4000/idea/2011/04/25/down-the-rabbit-hole.html">&lt;p&gt;영화 매트릭스(Matrix)에서 모피어스는 주인공 네오(키아누 리브스 분)에게 빨간색 약과 파란색 약 중 하나를 선택하라고 말한다. 파란색 약을 먹는다면 매트릭스의 세계 속에서 편하게 살 수 있었지만 네오는 ‘진짜 현실’에 대한 호기심으로 빨간색 약을 선택한다.&lt;/p&gt;

&lt;p&gt;그리고 눈앞에 펼쳐지는 광경에 경악을 금치 못한다. 앨리스가 이상한 나라를 보면서 그랬던 것처럼 말이다(영화 매트릭스는 ‘이상한 나라의 앨리스’에 대한 오마쥬 영화이다. 초반부에 나오는 ‘흰 토끼를 따라가라’는 암호는 ‘이상한 나라의 앨리스’의 장면을 패러디한 것이다.).&lt;/p&gt;

&lt;p&gt;네오와 앨리스는 바로 ‘호기심’ 때문에 편안하게 살아감을 포기하고 각각 빨간약, 토끼굴을 선택했다.&lt;/p&gt;

&lt;p&gt;메트릭스 속의 사람들은 프로그래밍 된 사회의 이미지를 소비한다. 그곳에서 나름 만족을 하며 살아가지만 실제 세상(메트릭스 밖)을 알지는 못한다. 심지어 메트릭스를 벗어난 한 사람이 다시 메트릭스에 들어가기를 원하는 장면도 나온다.&lt;/p&gt;

&lt;p&gt;하지만 호기심이 많은 사람들은 진실을 알고 싶어하고 또 모험을 갈망한다. 자신이 속한 시스템에 맞춰서 살기보다는 뭔가 다른 것을 찾기를 원한다. 위험을 감수해야 하지만 모험은 언제나 매력적이기 때문이다.&lt;/p&gt;

&lt;p&gt;난 빨간약을 선택했다. 그리고 잡스옹은 스텐포드에서 이런 말을 했다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Your time is limited, so don’t waste it living someone else’s life. Don’t be trapped by dogma — which is living with the results of other people’s thinking. Don’t let the noise of others’ opinions drown out your own inner voice. And most important, have the courage to follow your heart and intuition. They somehow already know what you truly want to become. Everything else is secondary.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;타성에 젖으면 끝이다. 용기를 갖으라고…&lt;/p&gt;</content><author><name></name></author><summary type="html">영화 매트릭스(Matrix)에서 모피어스는 주인공 네오(키아누 리브스 분)에게 빨간색 약과 파란색 약 중 하나를 선택하라고 말한다. 파란색 약을 먹는다면 매트릭스의 세계 속에서 편하게 살 수 있었지만 네오는 ‘진짜 현실’에 대한 호기심으로 빨간색 약을 선택한다.</summary></entry><entry><title type="html">Idea 00. 유능하고 경험 많은 개발자는 어디에 모여 살까?</title><link href="http://localhost:4000/idea/2011/03/20/where-is-the-developer.html" rel="alternate" type="text/html" title="Idea 00. 유능하고 경험 많은 개발자는 어디에 모여 살까?" /><published>2011-03-20T13:15:00+09:00</published><updated>2011-03-20T13:15:00+09:00</updated><id>http://localhost:4000/idea/2011/03/20/where-is-the-developer</id><content type="html" xml:base="http://localhost:4000/idea/2011/03/20/where-is-the-developer.html">&lt;p&gt;유능하고 경험 많은 개발자는 어디에 모여 살까? 우리 개발자는 매니저가 되는 것이 목표인가?&lt;/p&gt;

&lt;p&gt;2006년 가을 개발자라는 직업을 갖게되면서부터 자연스레 생긴 궁금증이다. 5년이 다되어 가는 시간동안 경험 많은 개발자들은 보기 힘었다. 왜 대부분의 개발자들은 매니저에 비해 미숙한거 같고 어리게만 느껴질까? (실제로 대부분의 개발자는 매니저에 비해 나이가 어리거나 그들의 부하직원인것 같다.)&lt;/p&gt;

&lt;p&gt;우리는 유능한 개발자들이 특정 연차가 되었을때 심화된 엔지니어링 테크를 타는 것이 아니고 매니저 테크를 타는 것을 쉽게 목격할 수 있다. 그들의 업무는 모델링, 알고리즘 풀어먹기, 불꽃 코딩 등등에서 회의하기, 메일보내기 답하기, 회의하기, 회의하기, 회의하기, 팀원이나 프로젝트의 일정이나 스펙을 관리하기, 회의하기로 바뀐다. 이제 좀 제대로 테크닉을 발휘 하면서 후임양성할때가 되었는데 개발로 부터 자연스럽게 멀어진다.&lt;/p&gt;

&lt;p&gt;일부(특히 개발을 살짝 맛만 봤다가 운이 좋게 매니저 테크를 탄) 매니저들은 개발은 쉬운 것, 애들이나 하는 것이라고 말하기도 한다.&lt;/p&gt;

&lt;p&gt;짧은 내 경험에서 알게된  개발(여기서 말하는 개발은 주로 엔지니어링)은 어렵다. 많은 것을 공부해야한다. 다양한 프로그래밍 언어는 물론이고 때로는 큰 규모의 프로그램을 구조화 하는 모델링 기법 혹은 알고리즘들, 수학에 관련되었을 수도 있고 새로나온 플렛폼 혹은 여러가지 프로그래밍 페러다임일 수도 있다. 최적의 제품을 제대로 만들기 위해서는 반드시 무엇인 가를 알아야 하고 공부해야할 경우가 있다. 개발자는 경력이 쌓일 수록 이런 것들을 공부해야 한다.(만약 아닌것 같고 그게 이글을 읽고 있는 사람이라면 제발 공부해라.) 특정 상황에선 현재로서는 해결할 수 없는 문제가 발생되기도 한다.  끊임없이 실험하고 방법을 찾으려고 시도할때는 꿈에서도 생각할 정도로 몰입해야하는 상황도 생긴다. 개발자라는 직업이 현실에는 의사, 변호사 같은 다른 전문직보다 진입장벽이 낮지만 그들은 사실 전문가이어야하고 전문직이어야 한다. 그래야 제대로 만들 수 있다.&lt;/p&gt;

&lt;p&gt;물론 매니저라는 직업이 나쁘다는 말을 하고 싶은 것이 아니다. 그들은 프로젝트에 필요한 직업이고 해야할 일이 있다. 매니지먼트 스킬은 엔지니어링 스킬과 조금 다른 테크이다. 난 단지 유능한 개발자들이 어설픈 매니저(물론 매니저가 더 맞고 천직이라고 느껴지면 가도 좋다.)가 되지 않고 유능한 개발자로 남아서 자신이 가지고 있는 기술을 풀어 먹었으면 좋을것 같다는 생각을 하는 것이다. 그러면 좋은 소프트웨어가 좀 더 많이 나오지 않을까? 하는 생각이든다.&lt;/p&gt;</content><author><name></name></author><summary type="html">유능하고 경험 많은 개발자는 어디에 모여 살까? 우리 개발자는 매니저가 되는 것이 목표인가?</summary></entry></feed>