<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.4.3">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2018-10-26T13:59:18+09:00</updated><id>http://localhost:4000/</id><title type="html">hackerwins blog</title><subtitle>Done is better than perfect.
</subtitle><entry><title type="html">Paper 02. A Conflict-Free Replicated JSON Datatype. 요약</title><link href="http://localhost:4000/paper/2018/10/26/a-conflict-free-replicated-json-datatype.html" rel="alternate" type="text/html" title="Paper 02. A Conflict-Free Replicated JSON Datatype. 요약" /><published>2018-10-26T13:14:00+09:00</published><updated>2018-10-26T13:14:00+09:00</updated><id>http://localhost:4000/paper/2018/10/26/a-conflict-free-replicated-json-datatype</id><content type="html" xml:base="http://localhost:4000/paper/2018/10/26/a-conflict-free-replicated-json-datatype.html">&lt;p&gt;“A Conflict-Free Replicated JSON Datatype.” 공부하면서 정리한 내용&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Original paper link: &lt;a href=&quot;https://arxiv.org/pdf/1608.03960.pdf&quot;&gt;link&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;a-conflict-free-replicated-json-datatype&quot;&gt;A Conflict-Free Replicated JSON Datatype&lt;/h2&gt;

&lt;h3 id=&quot;요약&quot;&gt;요약&lt;/h3&gt;

&lt;p&gt;일반적으로 다양한 애플리케이션은 자신의 모델을 범용적인(general-purpose) 형식으로 모델링한다. 이 모델의 단일 복제본을 순차적으로 수정할 때에는 문제없지만, 여러 디바이스 로컬 저장소에서 각각 동시에 수정한다면, 어떤 값이 남아있어야 하는지 알기 어렵다. 이 논문은 CRDT를 이용해서 동시 수정으로 발생하는 충돌(conflict)를 자동으로 해결하는 JSON 자료구조를 제안한다. 이 자료구조에 적용된 알고리즘은 클라이언트에서 병합을 처리하고 모바일이나 열악한 네트워크 환경에도 적용 가능하다.&lt;/p&gt;

&lt;h3 id=&quot;1-도입&quot;&gt;1. 도입&lt;/h3&gt;

&lt;p&gt;모바일 사용자는 오프라인시에도 계속해서 앱 사용이 가능하고 네트워크가 복구 될 때, 사용자의 다른 장비와 자동으로 동기화 되길 원한다. 이러한 종류의 앱은 캘린더, 주소록, 메모장, 할일 목록, 패스워드 등이있다. 또 협업 도구들은 여러 사용자가 문서 수정의 지연(delay)이 작은 환경에서 동시에 동일한 문서를 수정하는 기능을 필요로 한다.&lt;/p&gt;

&lt;p&gt;이러한 애플리케이션은 보통 로컬에서 직접 수정가능 하도록 각각의 디바이스에 애플리케이션의 상태를 저장한다(optimistic replication). 종래의 접근 방식은 네트워크 환경이 열악한 경우 사용 불가능했다. 네트워크의 상태에 무관하게 애플리케이션이 항상 동작해야하는 경우, 서로 다른 장치에서 임의의 수정을 실행할 수 있어야 하며, 수정 결과로 발생하는 충돌을 해결할 수 있어야 한다.&lt;/p&gt;

&lt;p&gt;가장 간단한 방법은 “last writer wins” 정책과 같이 충돌 발생시 특정 수정을 버려서 해결하는 것이지만 데이터 손실이 발생하므로 이러한 접근 방식이 적절하지 못할 때가 있다. 다른 대안으로 사용자가 수동으로 충돌을 해결하게 하는 방법이 있지만, 귀찮고 에러가 발생하기 쉬운 문제가 있다.&lt;/p&gt;

&lt;p&gt;최근 애플리케이션들은 이 문제를 임기응변(ad-hoc)적이거나 애플리케이션 마다 자신들의 상황에 맞게 해결한다. 이 논문은 범용적인 JSON 데이터 모델로 표현 가능하고 정보 유실없이 동시 수정이 가능한 데이터타입을 제안한다. 이 접근 방식은 JSON 데이터타입에 대한 동시 수정을 자동으로 병합한다. 충돌 업데이트를 기록하기 위한 일반 메커니즘(multi-value register)를 제안한다. 이 메커니즘은 프로그램적으로 남아있는 충돌을 해결하는 일관된 기반을 제공한다.&lt;/p&gt;

&lt;h4 id=&quot;11-json-data-model&quot;&gt;1.1 JSON Data Model&lt;/h4&gt;

&lt;p&gt;JSON은 인기있는 범용 데이터 인코딩 포맷으로 다양한 데이터베이스나 웹서비스에서 사용한다. JSON에 추가로 스키마를 지정해서 제약할 수 있지만, 이 논문에서는 스키마가 없는 경우만 고려했다.&lt;/p&gt;

&lt;p&gt;JSON 문서는 다음과 같이 두 형식의 브랜치(branch) 노드를 포함한 트리다.
Map: 순서가 지정되지 않고 문자열 키로 찾을 수 있는 자식을 갖고 있는 노드. 논문에서는 키를 불변형, 값을 가변형으로 취급한다.
List: 애플리케이션에서 지정한 순서의 자식을 갖고 있는 노드. 가변적이다.&lt;/p&gt;

&lt;p&gt;브랜치 노드의 자식은 브랜치 노드 혹은 말단 노드(leaf)이다. 트리의 말단에는 기본 타입의 값(primitive value, [string, number, boolean, null])이 위치한다. 이 논문에서는 말단 노드의 값을 불변형으로 취급하고 해당 말단 노드를 수정시에 새로운 값으로 등록한다.&lt;/p&gt;

&lt;p&gt;이 모델은 애플리케이션의 다양한 상태를 표현하는데 충분하다. 예를들어 텍스트 문서는 단일 문자의 리스트로 표현할 수 있다. 3.1 절에서는 더 복잡한 JSON으로 애플리케이션의 data를 모델링하는 예제를 살펴본다.&lt;/p&gt;

&lt;h4 id=&quot;12-복제replication와-충돌-해결conflict-resolution&quot;&gt;1.2 복제(replication)와 충돌 해결(conflict resolution)&lt;/h4&gt;

&lt;p&gt;이 논문은 JSON 문서의 본제본(replica)을 여러 디바이스에 갖고 자신의 복제본을 먼저 수정하고 비동기적으로 원격 복제본에 반영하는 시스템을 대상으로 한다(optimistic replication).&lt;/p&gt;

&lt;p&gt;이 논문에서 필요로 하는 네트워크 환경은 하나의 복제본의 수정사항을 다른 모든 원격 복제본에 전달하는 네트워크를 필요로 한다. 네트워크는 임의적으로 지연되거나 순서가 뒤집히거나 중복 메시지가 발생할 수 있음을 가정한다.&lt;/p&gt;

&lt;p&gt;이 논문이 다루는 범위는 클라이언트 측에 있고 메시지를 처리하거나 변환하는 서버가 필요 없으므로 P2P 네트워크에서도 사용할 수 있다.&lt;/p&gt;

&lt;p&gt;4절에서는 서로 다른 디바이스에서 동시에 JSON 문서를 편집할 때 발생하는 충돌을 어떻게 해결하는지 다룬다. 이 논문의 디자인은 3가지 원칙을 기반으로 한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;자료구조의 모든 복제본은 자동으로 동일한 상태로 수렴한다.&lt;/li&gt;
  &lt;li&gt;사용자의 입력은 동시 수정으로 인해 유실되지 않는다.&lt;/li&gt;
  &lt;li&gt;업데이트의 모든 조합의 순열들은 동일한 상태로 수렴한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;13-이-논문의-공헌-내용&quot;&gt;1.3 이 논문의 공헌 내용&lt;/h4&gt;

&lt;p&gt;이 논문이 공헌한 점은 JSON 자료구조의 동시 수정 발생시 자동으로 충돌을 해결하는 알고리즘을 정의한 것이다. 이전에도 리스트, 맵, 레지스터와 같은 자료형이 개별적으로 제안되었으나 이 논문은 각각의 자료구조를 통합하고 어떤 네트워크 토폴로지에 사용할 수 있도록 했다.&lt;/p&gt;

&lt;p&gt;맵과 리스트의 중첩 자료구조를 구성하면 트리의 서로 다른 레벨을 동시에 수정하는 것이 가능하기 때문에 단일 자료구조에서 발생하지 않는 문제가 발생한다. 이 문제들은 3.1 절에서 다룬다. 중첩 데이터 구조는 많은 애플리케이션의 중요한 요구사항이다.&lt;/p&gt;

&lt;h3 id=&quot;2-관련-작업&quot;&gt;2. 관련 작업&lt;/h3&gt;

&lt;h4 id=&quot;21-operation-transformation&quot;&gt;2.1 Operation Transformation&lt;/h4&gt;

&lt;p&gt;OT 기반 알고리즘은 동시편집 애플리케이션에서 오랫동안 사용되었다. 이 애플리케이션들은 대부분 문자열을 원소로하는 단일 리스트를 문서로 다루며 충첩 트리 자료구조를 지원하지 않는다. XML 문서를 편집하기 위해서 OT를 일반화한 일부 알고리즘은 충첩 리스트를 다뤘으나 이 논문이 다루는 충첩 맵을 다루지는 않았다. 또 OT 알고리즘은 동시에 발생하는 오퍼레이션의 수가 증가하면 급격히 성능이 저하된다.&lt;/p&gt;

&lt;p&gt;대다수의 OT 기반의 협업 시스템(Google Docs, Etherpad, Novell Vibe, Apache Wave)은 오퍼레이션의 순서를 결정하기 위한 단일 서버를 필요로 하는데, 이 디자인 개념은 Jupiter 시스템에서 왔다. 이 접근 방식은 변환 함수를 단순화하고 오류 발생을 줄이지만 P2P에서 사용할 수 없었다.&lt;/p&gt;

&lt;p&gt;협업 작업에 사용할 많은 보안 메시징 프로토콜은 각각의 수신자가 메시지를 동일한 순서로 볼 수 없을지도 모른다. Atomic broadcast 프로토콜을 사용하면 서버 없이도 오퍼레이션의 전체 순서를 보장할 수 있지만, 합의(consensus) 프로토콜과 마찬가지로 쿼럼에 각 노드들이 접근가능할 때에만 안전하게 처리한다. 이 P2P 시스템에서의 모바일 디바이스는 자주 오프라인이 되고 atomic broadcast는 쿼럼에 접근하기 위해서 문제가 발생해서 사용하기 어려울 것이다. 쿼럼 없이 이를 처리할 수 있는 방식은 causal ordering 이다.&lt;/p&gt;

&lt;p&gt;Google Realtime API는 임의의 중첩 리스트와 맵을 OT로 구현했고 Google Docs처럼 서버를 필요로 한다. 자세한 알고리즘은 아직 발표되지 않았다.&lt;/p&gt;

&lt;h4 id=&quot;22-crdt&quot;&gt;2.2 CRDT&lt;/h4&gt;

&lt;p&gt;CRDT는 동시 편집을 지원하는 자료구조로 동시 수정의 수렴을 보장하며 데이터타입에 메타데이타를 추가해서 생성시 오퍼레이션이 교환법칙(commutative)이 가능하도록 한다. 이 논문은 CRDT JSON 데이터타입을 다룬다.&lt;/p&gt;

&lt;p&gt;CRDT를 기반으로한 레지스터(register), 카운터(counter), 맵, 셋(sets)은 Riak과 같이 다양한 출시된 시스템에서 사용된다. 순서 리스트의 알고리즘은 WOOT, RGA, Treedoc, Logoot, LSEQ등 여러가지가 제안되었지만 모두 기본형 값을 사용하고 값으로 다른 CRDT를 갖는 충첩을 지원하지는 않았다.&lt;/p&gt;

&lt;p&gt;충첩 CRDT에 대한 연구는 최근에 진행되었다. Riak은 맵안에 카운터와 레지스터, 맵의 중첩이 가능했다. (생략…) 이 연구들 모두 리스트를 중첩하지는 않았지만, 이 논문에서 사용하는 의미체계의 기초가 된다. (생략…)
레지스터, 맵, 리스트들이 수년간 개별적으로 연구되었고 이 논문은 JSON 유사한 구조의 임의의 중첩 CRDT를 제안한다.&lt;/p&gt;

&lt;h4 id=&quot;23-다른-접근-방법&quot;&gt;2.3 다른 접근 방법&lt;/h4&gt;

&lt;p&gt;복제된 데이터 시스템은 동시 수정과 충돌을 해결해야 하지만, 기존에는 이 문제를 각 애플리케이션 마다 임기응변으로 해결했다. 예를 들어, Dynamo와 CouchDB는 여러 값이 같은 키에 동시에 쓰여지면 데이터베이스는 이러한 모든 값을 보존하고 충돌 해결을 애플리케이션에서 처리하도록 한다.(생략…)&lt;/p&gt;

&lt;p&gt;충돌 해결에 자주 사용하는 또 다른 접근법은 LWW(last writer wins)로, 여러 동시 수정 중 하나를 “승자”로 선택하고 다른 기록을 삭제한다. LWW는 Apache Cassandra에서 사용된다. 동시 수정으로 인해 사용자 입력이 손실되는 단점이 있다.&lt;/p&gt;

&lt;p&gt;트리 구조에 대한 동시 편집을 해결하는 것은 파일 동기화 분야에서 연구되었다. 마지막으로 Bayou에서는  오프라인 노드가 일시적으로 트랜잭션을 실행하고 다음 온라인 상태 일 때 이를 확인하는데 동일한 일련 순서로 트랜잭션을 실행하는 모든 서버에 의존이 있고 트랜잭션이 전제 조건에 따라 성공했는지 여부를 결정한다. Bayou는 직렬화가 필요하고 CRDT를 사용하여 표현할 수 없는 유일성 제약 조건과 같은 전역 불변량을 표현할 수 있다는 장점이 있다. Bayou의 단점은 애플리케이션이 명시적으로 처리해야하는 임시 트랜잭션이 롤백 될 수 있다는 점이고 CRDT는 하나의 복제본에서 수행 된 작업이 실패하지 않는다.&lt;/p&gt;

&lt;h3 id=&quot;3-자료구조-구성&quot;&gt;3. 자료구조 구성&lt;/h3&gt;

&lt;h4 id=&quot;31-동시-편집-예&quot;&gt;3.1 동시 편집 예&lt;/h4&gt;

&lt;p&gt;JSON 자료구조를 순차적으로 편집하는 의미론은 잘 알려져 있으며, 플랫한 맵 또는 리스트의 동시 편집은 기존 논문에서 철저히 조사되었다. 그러나 JSON CRDT에서 동시성과 중첩 된 데이터 구조 간의 상호 작용으로 인해 문제가 발생한다.&lt;/p&gt;

&lt;p&gt;다음 예제는 JSON 문서가 동시에 수정 될 때 발생할 수있는 몇 가지 상황을 보여 주며, 이 논문에서 제시한 알고리즘에 의해 처리되는 방법에 대해 알아본다. 예제에서는 p와 q라는 두 개의 복제본을 가정한다.복제본의 로컬 상태는 박스에 그렸고 로컬 상태의 수정 내용은 레이블이 있는 실선 화살표로 표시한다. 시간은 아래로 흐른다. 복제본은 로컬 상태만 변경하기 때문에 복제본 간에 변경에 대해서만 통신한다. 네트워크 통신은 점선 화살표로 표현했다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/2018-10-26-a-conflict-free-replicated-json-datatype/image1.png&quot; alt=&quot;image1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;그림 1에서는 키가 “key”이고 값이 “A”을 갖은 문서에서 리플리카 p는 값을 “B”로 설정하고 리플리카 q는 동시에 “C”로 설정한다. 이후 네트워크 통신을 통해 편집 내용을 받으면 충돌을 감지한다. 문자열 “B”와 “C”를 의미있게 병합 할 수 없기 때문에 시스템은 동시에 발생한 두 업데이트를 보존해야 한다. 이 데이터 유형은 다중 값 레지스터(multi-value register)로 불린다. 복제본은 레지스터에 단일 값만 할당 할 수 있지만 읽기시에 동시에 쓰인 값의 집합이 반환된다.&lt;/p&gt;

&lt;p&gt;다중 값 레지스터는 충돌 해결을 실제로 수행하지 않으므로 인상적인 CRDT는 아니다. 이 논문에서는 자동 병합 함수가 정의되지 않은 기본형에만 이 방식을 취한다. 하지만 다른 CRDT는 이를 처리한다(예 : 카운터 CRDT 또는 공동 편집에 사용하는 정렬된 리스트 CRDT).&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/2018-10-26-a-conflict-free-replicated-json-datatype/image18.png&quot; alt=&quot;image18&quot; /&gt;&lt;/p&gt;

&lt;p&gt;그림 2에서는 JSON 트리에서 다양한 레벨에서의 동시 편집의 예를 표현했다. 여기서 리플리카 p는 colors 맵에 “red”를 추가하고 동시에 리플리카 q는 colors 맵을 지운 다음 “green”을 추가한다. 빈 맵을 할당하는 대신, q는 colors 맵의 키를 제거한 다음 해당 키에 새 값을 할당한다. 이 예제의 어려움은 트리의 하위 레벨에서 “red”를 추가하는 것과 동시에 트리의 상위 레벨에서 colors 맵이 제거된다는 점이다.&lt;/p&gt;

&lt;p&gt;레벨간 충돌을 처리하는 방법중 하나는 트리의 상위에서 발생한 편집이 항상 해당 하위 트리에서 발생한 동시 편집을 무시하는 것이다. 이 경우, “red”의 추가는 상위 삭제(blanking-out)에 의해 무시되기 때문에 버린다. 그러나 이러한 동작은 동시 수정으로 인해 사용자 입력을 잃지 않아야 한다는 초기 요구 사항을 위반한다. 따라서 논문에서는 그림 2와 같이 모든 변경 사항을 보존하는 병합 의미론을 정의했다. “blue”는 최종 맵에서 제거되어야 하며 “빨간색”과 “녹색”은 명시 적으로 추가 되었기 때문에 맵에 추가되어야 한다. 이 동작은 Riak 의 CRDT 맵의 동작과 일치한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/2018-10-26-a-conflict-free-replicated-json-datatype/image15.png&quot; alt=&quot;image15&quot; /&gt;&lt;/p&gt;

&lt;p&gt;그림 3은 동일한 키의 리스트에서 발생하는 문제점을 표현했다. 두 개의 복제본이 동시에 동일한 키에 값을 삽입했을 때, p와 q는 각각 독립적으로 동일한 맵에 “grocery”키로 리스트를 만들고 리스트에 항목을 추가한다. 그림 1의 경우, 동일한 맵 키에 대한 동시 할당은 애플리케이션에 의해 해결했지만, 그림 3에서 두 값은 리스트에서 자동으로 병합한다. 각 복제본에 삽입 된 항목의 순서와 인접성을 보존하므로 병합 결과에서 “eggs”뒤에 “ham”이 있고 “milk”뒤에 “flour”가 추가된다. 어떤 복제본의 항목이 병합 된 결과에서 처음으로 나타 나야하는지에 대한 정보는 없으므로 “eggs, ham, milk, flour”와 “milk, flour, eggs, ham”중 하나가 선택된다. 단, 모든 복제본은 동일한 순서로 병합된다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/2018-10-26-a-conflict-free-replicated-json-datatype/image10.png&quot; alt=&quot;image10&quot; /&gt;&lt;/p&gt;

&lt;p&gt;그림 4는 문서를 문자 리스트로 처리해서 협업 텍스트 편집기를 구현하는 방법을 표현했다. 병합 된 결과에  모든 변경 사항이 보존된다. “a”앞에 “y”가 삽입, “x”와 “z”는 “a”와 “c”사이에 삽입 “b”는 삭제됨.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/2018-10-26-a-conflict-free-replicated-json-datatype/image13.png&quot; alt=&quot;image13&quot; /&gt;&lt;/p&gt;

&lt;p&gt;그림 5는 그림 3처럼 두 개의 복제본이 동시에 동일한 맵 키를 삽입 했지만 다른 타입을 값으로 할당하는 문제를 표현했다. p는 중첩 맵을 삽입했고 q는 리스트를 삽입했다. 이러한 데이터 유형은 의미있게 병합할 수 없으므로 두 값을 별도로 보존한다. 이 논문은 맵의 각 키에 map, list, register 값에 대한 타입 주석(mapT, listT, regT)을 태깅해서 각 유형이 별도의 네임 스페이스를 유지하도록 했다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/2018-10-26-a-conflict-free-replicated-json-datatype/image14.png&quot; alt=&quot;image14&quot; /&gt;&lt;/p&gt;

&lt;p&gt;마지막으로, 그림 6은 모든 사용자 입력을 보존하는 원칙의 한계를 표현했다. p가 항목을 리스트에서 제거하는 동시에 q는 항목을 완료로 표시한다. 변경 사항이 병합되면 맵 키 “done”이 참인 제목이 없는 값이 남는다. 이 동작은 그림 2에서는 정상 동작하지만 여기에서는 오류를 범한다. 이 경우, 동시 갱신 중 하나를 버리고 작업 항목에 “제목”및 “완료” 필드가 있는 내재적 스키마를 보존하는 것이 더 바람직하다.&lt;/p&gt;

&lt;h4 id=&quot;32-json-vs-xml&quot;&gt;3.2 JSON vs XML&lt;/h4&gt;

&lt;p&gt;JSON의 일반적인 대안은 XML로 협업 편집은 이전에 연구되었다. XML과 JSON의 트리 구조는 매우 유사하지만 중요한 차이가 있다.&lt;/p&gt;

&lt;p&gt;JSON에는 임의의 맵과 리스트를 중첩 할 수 있는 구조를 갖고 있다. 반면 XML은 자식으로는 리스트를 갖고 attribute는 맵을 갖지만 중첩 구조를 허용하지 않는다. 따라서 XML은 리스트는 값으로 맵을 지원하지만 맵은 값으로 리스트를 지원하지 않는다. 따라서 XML은 JSON보다 표현력이 부족하다. 그림 3과 5의 시나리오는 XML에서 구현할 수 없다. 일부 애플리케이션은 XML 문서의 하위 attribute에 맵과 유사한 의미를 첨부하지만 이 구조는 XML 자체의 특성은 아다. 동일한 키를 가진 자식이 여러 개 동시에 생성되는 경우 기존 알고리즘은 그림 3과 같이 병합하지 않고 동일한 키를 가진 중복 자식을 만들어야한다.&lt;/p&gt;

&lt;h4 id=&quot;33-문서-편집-api&quot;&gt;3.3 문서 편집 API&lt;/h4&gt;

&lt;p&gt;협업 가능한 데이터 구조에 대한 의미(semantics)를 정의하기 위해 먼저 모든 복제본에서 로컬에 실행하며 해당 복제본을 쿼리하고 수정할 수 있는 간단한 명령 언어(command language)를 그림 7처럼 정의한다. 읽기 쿼리를 수행하면 부작용(side effect)이 없지만 문서를 수정하면 부작용이 발생하는 작업이 생성된다. 이러한 작업은 문서의 로컬 복사본에 즉시 적용되며 다른 복제본에 비동기(asynchronous)로 브로드 캐스팅 큐에 추가된다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/2018-10-26-a-conflict-free-replicated-json-datatype/image4.png&quot; alt=&quot;image4&quot; /&gt;&lt;/p&gt;

&lt;p&gt;명령 언어의 구문(syntax)은 그림 7에 있다. 완전한 프로그래밍 언어가 아니라 문서 상태를 쿼리하고 수정하는 API이다. 애플리케이션은 사용자 입력을 받아 API에 일련의 명령(무한한)을 발행한다. API는 일관된 병합 의미를 정의 할 수 있도록 많은 프로그래밍 언어에서 발견되는 JSON 라이브러리와 약간 다르다.&lt;/p&gt;

&lt;p&gt;먼저 공식적인 의미를 부여하기 전에 언어를 비공식적으로 설명한다. 표현식 구조 EXPR은 문서의 위치를 ​​식별하는 커서를 구성하는 데 사용된다. 표현식(expression)은 JSON 문서 트리의 루트를 식별하는 특수 토큰 doc 또는 let 명령에서 이전에 정의 된 변수 x로 시작한다. 이 표현식은 왼쪽에서 오른쪽으로 트리가 잎을 향해 잎을 향해 이동할 때 커서가 취하는 경로를 정의한다. 연산자 .get (key)는 맵에서 키를 선택하고 .idx (n)은 정렬 된 순서의 n 번째 요소를 선택한다.&lt;/p&gt;

&lt;p&gt;또한 EXPR은 문서의 상태 질의가 가능하다. keys는 현재 커서에서 맵의 키들을 반환하고, values는 현재 커서의 다중 값 레지스터의 내용을 반환한다. 명령 CMD는 로컬 변수(let)의 값을 설정하거나 네트워크 통신 (yield)을 수행해서 문서를 수정한다. 문서는 리스트에 요소를 삽입하여 레지스터(연산자 : =는 레지스터 값을 할당)에 쓰거나 (insertAfter는 커서로 식별 된 기존 요소 다음에 새 요소를 배치) 또는 리스트 또는 맵에서 요소를 삭제할 수 있다(delete는 커서로 식별 된 요소를 삭제).&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/2018-10-26-a-conflict-free-replicated-json-datatype/image3.png&quot; alt=&quot;image3&quot; /&gt;&lt;/p&gt;

&lt;p&gt;그림 8은 쇼핑리스트를 표현하는 새로운 문서를 구성하는 명령들의 예다. 먼저 문서는 빈 맵 리터럴 인 {}로 설정되고 그 맵 내의 키 “shopping”은 빈 리스트 []로 설정한다. 세 번째 행은 “shopping”키로 이동하여 리스트의 헤드(head)를 선택하여 커서를 head라는 변수에 할당한다. 리스트 요소 “eggs”가 리스트의 헤드에 삽입된다. 5 행에서 변수 egg는 리스트 요소 “eggs”를 가리키는 커서로 할당된다. 그런 다음 헤드에 “cheese”, “eggs”뒤에 “milk”라는 두 가지 요소가 삽입된다. 커서 eggs는 색인에 의해서가 아니라 ID에 의해 리스트 요소를 식별한다. “cheese” 삽입 후 요소 “eggs”은 index 1에서 2로 변경되지만 “milk”는 “eggs” 다음에 삽입된다. 나중에 보게 되겠지만, 이 기능은 동시 수정이있을 때 바람직한 의미를 얻기 위해 유용하다(Cursor).&lt;/p&gt;

&lt;h3 id=&quot;4-형식-의미론formal-semantics&quot;&gt;4. 형식 의미론(Formal Semantics)&lt;/h3&gt;

&lt;p&gt;이어서 3절에서 알아본 동시 의미론을 성취하는 방법을 형식적으로 설명한다. 리플리카 p의 상태는 유한 부분 함수(finite partial function) 인 Ap에 의해 설명된다. 명령 언어의 평가 규칙은 로컬 상태 Ap를 검사하고 수정하며 Aq(다른 리플리카 q는 p와 다름)와 의존성이 없다. 복제본 간의 유일한 통신은 yield 명령을 평가할 때 발생하는데, 이는 나중에 알아본다. 지금은 단일 복제본 p의 명령 실행에 대해 집중적으로 알아본다.&lt;/p&gt;

&lt;h4 id=&quot;41-표현식-평가expression-evaluation&quot;&gt;4.1 표현식 평가(Expression Evaluation)&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/2018-10-26-a-conflict-free-replicated-json-datatype/image19.png&quot; alt=&quot;image19&quot; /&gt;&lt;/p&gt;

&lt;p&gt;그림 9는 명령 언어에서 EXPR 표현식을 평가하는 규칙이며 로컬 복제본 상태 Ap의 컨텍스트에서 평가된다. EXEC 규칙은 명령이 순차적으로 실행된다는 가정을 공식화했다. LET 규칙은 프로그램이 로컬 상태에 추가한 로컬 변수를 정의하도록 한다(표기법 Ap [x → cur]은 Ap와 동일하지만 Ap(x) = cur을 제외한 부분 함수를 나타냄). VAR 규칙은 애플리케이션이 이전에 정의한 변수의 값을 검색 할 수 있게한다.&lt;/p&gt;

&lt;p&gt;이어지는 규칙은 표현식이 커서로 평가되는 방법을 표현했다. 이는 문서 트리의 루트에서 일부 브랜치 또는 리프 노드까지의 경로를 나타내며 JSON 문서의 특정 위치를 모호하지 않게 식별한다. 커서는 변경 불가능한 키와 식별자로만 구성되므로 네트워크를 통해 다른 복제본으로 보낼 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/2018-10-26-a-conflict-free-replicated-json-datatype/image12.png&quot; alt=&quot;image12&quot; /&gt;&lt;/p&gt;

&lt;p&gt;예를 들어, id (1)이 이 리스트를 삽입 한 작업의 고유 식별자라고 가정 할 때, cursor(mapT(doc), listT( “shopping”), id1)는 그림 8의 리스트 요소 “eggs”를 나타내는 커서이다. 요소 (4.2.1절에서 이 식별자들에 대해 알아본다). 커서는 로컬 복제본 상태 구조 Ap를 통해 경로로 해석되며 왼쪽에서 오른쪽으로 순서로 루트의 doc 맵에서 시작해서 listT 타입의 “shopping” 항목을 탐색하고 ID가 1인 식별자인 리스트 요소로 끝난다. 일반적으로, 커서(&amp;lt;k1, …, kn-1&amp;gt;, kn)는 키 k1,. . . , kn-1과 항상 존재하는 최종키(kn)으로 구성된다. kn은 벡터의 마지막 요소인데, 벡터의 다른 요소에는 traversal 되는 분기 노드의 데이터 유형으로 mapT 또는 listT 태그가 지정되는 반면 데이터 유형이 태깅되지 않는다는 점이 다르다.&lt;/p&gt;

&lt;p&gt;그림 9의 DOC 규칙은 특수 원자 doc를 사용하여 문서의 루트를 참조하는 가장 간단한 커서(hi, doc)를 정의한다. GET 규칙은 커서로 맵의 특정 키로 이동한다. 예를 들어, doc.get( “shopping”) 표현식은 DOC 및 GET 규칙을 적용하여 cursor(&amp;lt;mapT(doc)&amp;gt;, “shopping”)로 평가된다. doc.get(…) 표현식은 doc가 mapT 유형임을 암시적으로 나타낸다.&lt;/p&gt;

&lt;p&gt;규칙 IDX1…5는 .idx(n)표현식을 평가하여 커서를 리스트의 특정 요소로 이동시키는 방법을 정의한다. IDX1은 리스트의 헤드를 나타내는 커서를 구성하고 이어지는 규칙에 위임해서 리스트를 검사한다. IDX2는 커서의 키 벡터에 따라 로컬 상태를 재귀적으로 찾아낸다. 키 벡터가 비어있을 때 컨텍스트 ctx는 문제의 리스트를 저장하는 Ap의 하위 트리이며 규칙 IDX3, 4, 5는 원하는 요소가 발견 될 때까지 해당 리스트에 반복 수행한다. IDX5는 인덱스가 0에 도달하면 반복문을 종료하고 IDX3은 다음 요소로 이동하여 인덱스를 감소 시키며 IDX4는 삭제 됨으로 표시된 리스트 요소를 건너뛴다. 이 구조는 링크드리스트과 유사하다(각 리스트 요소는 고유 한 식별자 k와 k 다음에 오는 요소의 ID를 구하는 next(k) 부분 함수를 갖음).&lt;/p&gt;

&lt;p&gt;삭제된 요소는 링크드 리스트 구조에서 제거되지 않지만 삭제 된 것으로 표시하는데(tombstone) 이를 위해
요소에 대한 존재 여부를 알 수 있는 pres(k)를 유지한다. 리스트 요소가 삭제되면 pres 집합에서 제거해서 삭제로 표시한다. 그러나 리스트 요소를 참조하는 일은 동시 작업으로 인해 pres 세트가 다시 비어 있지 않게 될 수 있다(그림 2 및 6의 상황을 초래). 규칙 IDX4는 색인을 감소시키지 않고(즉, 리스트 요소로 계산하지 않음) 다음 요소로 이동한다.&lt;/p&gt;

&lt;p&gt;KEYS1, 2, 3 규칙은 애플리케이션이 맵에서 키 집합을 검사 할 수있게 한다. 이 집합은 로컬 상태를 검사하고 현재 상태 집합이 비어있는 키를 제외하여 결정된다(키가 삭제되었음을 나타냄). 마지막으로, VAL1,2,3 규칙은 IDX 규칙과 유사한 재귀적 규칙 구조를 사용하여 애플리케이션이 특정 커서 위치에서 레지스터의 내용을 읽을 수 있게한다. 레지스터는 로컬 상태의 regT 유형 주석을 사용하여 표현된다. 복제본은 레지스터에 단일 값만 할당 할 수 있지만 여러 개의 복제본이 동시에 값을 할당하면 레지스터에 여러 값이 포함될 수 있다.&lt;/p&gt;

&lt;h4 id=&quot;42-오퍼레이션-생성하기&quot;&gt;4.2 오퍼레이션 생성하기&lt;/h4&gt;

&lt;p&gt;오퍼레이션(Operation)은 문서의 상태를 명령(command)으로 변경하면 발생하는 변환(mutation)을 표현한다. 이 논문의 의미론에서, 명령은 로컬 복제 상태 Ap를 직접 수정하지 않고 오퍼레이션만 생성 한 뒤 즉시 Ap에 적용되고 동일한 오퍼레이션이 다른 복제본에도 비동기적으로 브로드캐스팅된다.&lt;/p&gt;

&lt;h4 id=&quot;421-램포트-시계lamport-timestamp&quot;&gt;4.2.1 램포트 시계(Lamport timestamp)&lt;/h4&gt;

&lt;p&gt;모든 오퍼레이션에는 로컬 상태와 커서에서 사용되는 고유 한 식별자(unique identifier)가 제공된다. 요소가 리스트에 삽입되거나 값이 레지스터에 할당 될 때마다 새 리스트 요소 또는 레지스터 값은 이를 생성한 작업의 식별자로 구분된다. 복제본 간의 동기 조정을 필요로하지 않고 전역적으로 고유한 작업 식별자를 생성하기 위해 램포트 시계를 사용한다. 램포트 시계는 Pair(c, p)이며, 여기서 p ∈ ReplicaID는 편집이 이루어진 복제본의 유일한 식별자 (예 : 공개 키의 해시)이고 c ∈ N은 저장된 카운터로 각 복제본에서 모든 작업에 대해 증가한다. 각 복제본은 엄격하게 단조(monotonically) 증가하는 카운터 값 c의 시퀀스를 생성하므로 Pair (c, p)는 고유하다. 복제본이 로컬에 저장된 카운터 값보다 큰 카운터 값 c를 갖는 연산을 수신하면 로컬 카운터는 수신 받은 카운터의 값으로 증가한다. 이렇게하면 o1가 o2보다 먼저 발생하는 경우(즉, o2를 생성 한 복제본이 o2가 생성되기 전에 o1을 받고 처리 한 경우) o2가 o1보다 큰 카운터 값을 가져야한다. 동시 작업만 동일한 카운터 값을 가질 수 있다. 램포트 시계로 오퍼레이션에 대해 전체 정렬을 할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/2018-10-26-a-conflict-free-replicated-json-datatype/image9.png&quot; alt=&quot;image9&quot; /&gt;&lt;/p&gt;

&lt;p&gt;한 작업이 다른 작업보다 먼저 발생하면 이 순서는 인과 관계와 일치한다(이전 작업의 timestamp가 더 낮음). 두 작업이 동시에 수행되는 경우 &amp;lt; 에 따른 순서는 임의적(arbitrary)이지만 결정적(deterministic)이다. 이 정렬 속성은 정렬 된 리스트의 의미론 정의에 중요하다.&lt;/p&gt;

&lt;h4 id=&quot;422-오퍼레이션-구조&quot;&gt;4.2.2 오퍼레이션 구조&lt;/h4&gt;

&lt;p&gt;오퍼레이션은 튜플로 id는 오퍼레이션을 식별하는 램포트 시계, cur는 변경의 문서 내의 위치를 ​​나타내는 커서, mut는 지정된 위치의 변환, deps는 인과 관계가 의존된 오퍼레이션의 집합이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/2018-10-26-a-conflict-free-replicated-json-datatype/image8.png&quot; alt=&quot;image8&quot; /&gt;&lt;/p&gt;

&lt;p&gt;o2가 replica p에 의해 생성 된 경우, o2의 인과 관계는 o2가 생성 된 시점에 이미 p에 적용된 모든 연산이다. 이 논문에서, 모든 인과 관계의 램포트 시계 집합으로 deps를 정의한다. 실제 구현에서는 이 집합이 비실용적으로 커지므로 인과 관계의 간략한 표현이 대신 사용된다(예 : 버전 벡터, 상태 벡터 또는 점선 버전 벡터). 그러나 의미론에서 모호성을 피하기 위해 의존성을 간단한 오퍼레이션 ID 세트로 설명한다. 인과 관계 종속성의 목적은 오퍼레이션에 부분적 순서를 부여하는 것이다. 오퍼레이션은 “이전에 발생한 모든 작업”이 적용된 후에 만 ​​적용될 수 있다. 특히 특정 복제본에서 생성된 작업 시퀀스가 ​​다른 모든 복제본에서 동일한 순서로 적용된다는 의미이다. 동시 작업(즉, 어느 방향으로도 인과 관계가없는 경우)은 임의의 순서로 적용 할 수 있다.&lt;/p&gt;

&lt;h4 id=&quot;423-오퍼레이션-의미론semantics-of-generating-operations&quot;&gt;4.2.3 오퍼레이션 의미론(Semantics of Generating Operations)&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/2018-10-26-a-conflict-free-replicated-json-datatype/image6.png&quot; alt=&quot;image6&quot; /&gt;&lt;/p&gt;

&lt;p&gt;MAKE-ASSIGN, MAKE-INSERT 및 MAKE-DELETE 규칙은 명령이 문서를 어떻게 변경시키는 지 정의한다. 셋 모두 MAKE-OP 규칙에 위임하여 작업을 생성하고 문서에 반영한다. MAKE-OP는 복제본 p에 적용된 모든 작업 ID 집합인 Ap(ops)의 기존 카운터보다 1만큼 큰 카운터 값을 선택하여 새로운 램포트 시계를 생성한다. MAKE-OP는 위에 설명 된 양식의 op() 튜플을 구성하고 APPLY-LOCAL 규칙에 위임하여 작업을 처리한다. APPLY-LOCAL은 다음 세 가지 작업을 수행한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;오퍼레이션을 평가하고 수정된 로컬 상태 Ap’를 생성&lt;/li&gt;
  &lt;li&gt;생성된 오퍼레이션 대기열 Ap(queue)에 오퍼레이션을 추가&lt;/li&gt;
  &lt;li&gt;해당 ID를 처리 된 연산 집합 Ap(ops)에 추가.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;(Burckhardt et al.에서 영감을 받은) yield 명령은 다른 복제본과의 작업 송수신 및 원격 복제본의 작업 적용하는 네트워크 통신을 수행한다. APPLY-REMOTE, SEND, RECV 및 YIELD 규칙은 yield의 의미를 정의한다.&lt;/p&gt;

&lt;p&gt;이러한 규칙 모두 네트워크의 비동기성을 모델링인 yield를 평가하는데 사용하기 때문에 비결정적(nondeterministic)이다. 하나의 복제본에서 보내는 메시지는 임의의 차후 시점에 다른 복제본에 도착하며, 메시지 순서의 보장은 없다. 네트워크에서 SEND 규칙은 APPLY-LOCAL에의해 Ap(queue)에 배치된 모든 작업을 가져 와서 송신 버퍼 Ap(send)에 추가한다. 따라서 RECV 규칙은 복제본 q의 전송 버퍼에서 작업을 수행하여 복제본 p의 수신 버퍼 Ap(recv)에 추가한다. 이것은 하나 이상의 복제본을 포함하는 유일한 규칙이며 모든 네트워크 통신에 적용 가능하다.&lt;/p&gt;

&lt;p&gt;수신 버퍼 Ap(recv)에 오퍼레이션이 추가되면 APPLY-REMOTE 규칙을 적용할 수 있다. 작업이 아직 처리되지 않았고 해당 인과 관계가 충족된다는 전제하에 APPLY-REMOTE는 APPLY-LOCAL과 같은 방식으로 오퍼레이션을 적용하고 ID를 처리 된 작업 집합 Ap(ops)에 추가한다. 실제 문서 수정은 다음 절에서 알아본다.&lt;/p&gt;

&lt;h4 id=&quot;43-오퍼레이션-적용하기&quot;&gt;4.3 오퍼레이션 적용하기&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/2018-10-26-a-conflict-free-replicated-json-datatype/image7.png&quot; alt=&quot;image7&quot; /&gt;&lt;/p&gt;

&lt;p&gt;그림 11은 오퍼레이션 op를 컨텍스트 ctx에 적용하여 업데이트 된 컨텍스트 ctx0을 생성하는 규칙을 나타낸다. 컨텍스트는 초기에 복제 상태 Ap이지만, 규칙들이 재귀적으로 반영될 때 상태의 서브 트리를 참조하기도 한다. 이 규칙들은 APPLY-LOCAL 및 APPLY-REMOTE가 문서의 상태 업데이트를 수행하는 데 사용된다.&lt;/p&gt;

&lt;p&gt;오퍼레이션 커서의 키 벡터가 비어 있지 않으면 먼저 DESCEND 규칙이 적용된다. 키에 설명한 경로를 따라 문서 트리를 재귀적으로 따라간다. 트리 노드가 로컬 복제본 상태에 이미 존재하면 CHILD-GET가 이를 찾는다. 그렇지 않으면 CHILD-MAP과 CHILD-LIST가 각각 빈 맵 또는 리스트를 생성한다.&lt;/p&gt;

&lt;p&gt;또한 DESCEND 규칙은 커서에 의해 기술 된 경로를 따라 각 트리 노드에서 ADD-ID1, 2를 호출하고, pres(k)에 오퍼레이션 ID를 추가하여 서브 트리가 이 오퍼레이션에 의해 만들어진 변환을 포함함을 나타낸다.&lt;/p&gt;

&lt;p&gt;그림 11의 나머지 규칙은 커서에 있는 키의 벡터가 비어있는 경우에 적용된다. 이는 변환이 적용되는 트리 노드의 컨텍스트로 내려갈 때 적용된다. ASSIGN 규칙은 레지스터에 기본형 값을 할당하는 것을 처리하고, EMPTY-MAP은 값이 빈 맵 리터럴 {}, EMPTY-LIST가 빈리스트 []의 할당을 처리한다. 이러한 세 가지 할당 규칙은 유사한 구조를 갖는다. 먼저 커서에서 이전 값을 지우고(다음 절에서 설명), 오퍼레이션 ID를 현재 pres 집합에 추가 한 다음 마지막으로 새 값을 로컬 상태 트리에 통합한다.&lt;/p&gt;

&lt;p&gt;INSERT1,2 규칙은 순서가 지정된 리스트에 새 요소의 삽입을 처리한다. 이 경우 커서는 list 요소 prev를 참조하고 새 요소는 리스트의 해당 위치 다음에 삽입된다. INSERT1은 링크드 리스트 구조를 조작하여 삽입을 수행한다. INSERT2는 동일한 위치에 리스트 요소를 동시에 삽입하는 다중 복제본의 경우를 처리하고 램포트 시계의 순서 관계를 사용하여 일관되게 삽입 지점을 결정한다. 논문의 삽입 처리에 대한 접근법은 RGA 알고리즘에 기반을 두고있다. 이 규칙은 모든 복제본이 동일한 상태로 수렴된다는 것을 보여준다.&lt;/p&gt;

&lt;h4 id=&quot;431-이전-상태-정리하기&quot;&gt;4.3.1 이전 상태 정리하기&lt;/h4&gt;

&lt;p&gt;할당 및 삭제 작업은 그림 2와 같이 동시에 이전 상태(덮어 쓰거나 삭제 된 값)가 지워지는 동시 수정이 손실되지 않도록 해야한다. 이 지우기 프로세스를 처리하는 규칙은 그림 12에 있다. 무언가를 지우는 효과는 동시 작업의 영향을 받지 않은 채로 현재 작업의 원인이되는 작업을 취소하여 빈 상태로 다시 설정하는 것이다.&lt;/p&gt;

&lt;p&gt;삭제 연산은 커서가 가리키는 리스트의 요소나 맵의 키에서 삭제한다. DELETE 규칙은 CLEAR-ELEM에 위임하여 이 오퍼레이션을 평가한다. 차례대로 CLEAR-ELEM은 mapT, listT 또는 regT 유형인지 여부에 관계없이 CLEAR-ANY를 사용하여 지정된 키가 있는 데이터를 지우고 중첩된 작업 ID를 포함하도록 현재 상태를 업데이트하고 deps의 기존 오퍼레이션들을 제거한다.&lt;/p&gt;

&lt;p&gt;CLEAR-ANY은 해당 키가 ctx에 나타나면 CLEAR-MAP1, CLEAR-LIST1 및 CLEAR-REG로 처리하고 키가 없는 경우 CLEAR-NONE(아무 것도 수행하지 않음)으로 처리한다.&lt;/p&gt;

&lt;p&gt;ASSIGN 규칙에 정의한 것 처럼 레지스터는 오퍼레이션 ID에서 값의 맵핑을 관리한다. CLEAR-REG는 deps에 나타나는 모든 오퍼레이션 ID(즉, 삭제 작업보다 먼저 발생 함)를 삭제하지만 deps에 표시되지 않는 모든 오퍼레이션 ID(삭제 작업과 동시에 발생하는 할당 오퍼레이션)를 유지하여 레지스터를 업데이트한다.
맵과 리스트 지우기도 비슷한 접근 방식을 취한다. 각 요소는 clearElem을 사용하여 재귀적으로 지워지고 pres 집합은 deps를 제외하도록 업데이트된다. 따라서, 정리 오퍼레이션 이전에 변경이 발생하는 모든 리스트 요소 또는 맵 항목은 빈 존재 세트로 끝날 것이므로 삭제 된 것으로 간주된다. 지우기 오퍼레이션과 동시에 수행되는 오퍼레이션을 포함하는 맵 또는 리스트 요소는 보존된다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/2018-10-26-a-conflict-free-replicated-json-datatype/image16.png&quot; alt=&quot;image16&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;44-수렴convergence&quot;&gt;4.4 수렴(Convergence)&lt;/h4&gt;

&lt;p&gt;1.2 절에서 설명한 핵심 요구 사항처럼 CRDT의 모든 복제본은 자동으로 동일한 상태로 수렴되어야한다. 이제 이 개념을 공식화하고 그림 9~12의 규칙이 이 요구 사항을 충족함에 대해 알아본다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/2018-10-26-a-conflict-free-replicated-json-datatype/image11.png&quot; alt=&quot;image11&quot; /&gt;&lt;/p&gt;

&lt;p&gt;정의 1 (유효한 실행). 유효한 실행은 일련의 복제본 {p1,. . . , pk}에서 생성한 오퍼레이션 집합으로 각 오퍼레이션은 걸리지(stuck) 않고 명령 시퀀스 &amp;lt;cmd1; … ;cmd n&amp;gt;를 축소(reduce)한다.&lt;/p&gt;

&lt;p&gt;축소(reduction)는 모든 전제 조건이 충족되는 규칙의 적용이 없으면 걸리게 된다. 예를 들어, idx(n)가 리스트의 끝을 지나 반복문 수행하면, 그림 9의 IDX3, 4 규칙은 멈추는데, 이는 n이 리스트의 삭제되지 않은 요소의 수보다 크면 발생한다. 실제 구현에서는 런타임 오류가 발생한다. 멈추지 않는 실행에 대해 유효한 실행을 제한함으로써 오퍼레이션이 실제로 존재하는 리스트 요소만 참조하도록 한다.&lt;/p&gt;

&lt;p&gt;yield 명령을 호출하지 않기 때문에(또는 yield의 비결정적 실행이 RECV 규칙을 적용하지 않기 때문에) 실행이 네트워크 통신을 절대로 수행하지 않는 것이 유효하다. 축소가 멈추는 지 여부를 결정하기 위해 복제본의 로컬 상태만 필요로 한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/2018-10-26-a-conflict-free-replicated-json-datatype/image17.png&quot; alt=&quot;image17&quot; /&gt;&lt;/p&gt;

&lt;p&gt;정의 2 (히스토리). 히스토리(history)는 APPLY-LOCAL 및 APPLY-REMOTE 규칙을 적용하여 특정 복제본 p에 적용된 순서대로 일련의 작업이다.&lt;/p&gt;

&lt;p&gt;평가 규칙은 주어진 복제본에서 한 번에 하나의 오퍼레이션을 순차적으로 적용하므로 순서가 잘 정의된다. 2개의 복제본 p, q가 동일한 오퍼레이션 집합을 적용한다고 할지라도, 즉 Ap(ops) = Aq(ops)인 경우, 그들은 상이한 순서로 임의의 동시 오퍼레이션을 적용 할 수 있다. APPLY-REMOTE의 전제 op.deps ⊆ Ap(ops)로 인해, 히스토리는 인과 관계와 일치한다. 오퍼레이션에 인과 관계가 있는 경우, 히스토리의 종속성 이후 특정 위치에 존재한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/2018-10-26-a-conflict-free-replicated-json-datatype/image2.png&quot; alt=&quot;image2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;정의 3 (문서 상태). 복제본 p의 문서 상태는 문서를 포함한 Ap의 하위 트리이다(Ap(mapT(doc)) 또는 Ap (listT(doc)) 또는 Ap(regT(doc))).&lt;/p&gt;

&lt;p&gt;Ap는 let으로 정의한 변수를 포함하는데, 이는 하나의 복제본에 대해 로컬이며 복제 된 상태의 일부가 아니다. 문서 상태의 정의는 이러한 변수를 제외한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/2018-10-26-a-conflict-free-replicated-json-datatype/image5.png&quot; alt=&quot;image5&quot; /&gt;&lt;/p&gt;

&lt;p&gt;정리. 유효한 실행에 참여한 두 개의 복제본 p와 q에 대해 Ap (ops) = Aq (ops)이면 p와 q는 동일한 문서 상태를 갖는다.&lt;/p&gt;

&lt;p&gt;이 정리는 부록에서 증명한다. 이것은 수렴의 안전성을 공식화한다. 두 개의 복제본이 동일한 순서의 오퍼레이션을 다른 순서로 처리 한 경우 동일한 상태로 수렴한다. 활성 속성(aliveness)과 함께, 모든 복제본이 결국 모든 오퍼레이션을 처리하므로 원하는 수렴 개념을 얻는디. 모든 복제본은 결국 동일한 상태로 끝난다.&lt;/p&gt;

&lt;p&gt;활성 속성은 충분히 자주 yeild를 호출하는 복제본의 가정과 공정하게 선택되는 yeild에 대한 모든 비결정적 규칙에 따라 달라진다. 이 논문에서 활성 속성을 공식화하지 않지만, 일반적으로 네트워크 중단은 유한한 기간이기 때문에 실제로는 적용될 수 있다고 주장한다.&lt;/p&gt;

&lt;h3 id=&quot;5-결론-향후-작업&quot;&gt;5. 결론, 향후 작업&lt;/h3&gt;

&lt;p&gt;이 논문에서는 JSON 데이터 모델을 사용하여 리스트, 맵 및 레지스터의 중첩 CRDT를 작성하는 방법을 설명했다. 임의로 중첩 된 리스트, 맵을 지원하며 복제본이 네트워크 통신을 기다리지 않고 데이터를 임의로 변경할 수 있다. 복제본은 비동기적 조작의 형태로 다른 복제본에 변형을 전송한다. 동시 오퍼레이션은 교환 가능(commutative)하므로 애플리케이션 별 충돌 해결 로직이 없어도 복제본이 동일한 상태로 수렴 된다.&lt;/p&gt;

&lt;p&gt;이 논문은 JSON CRDT의 형식 의미론에 중점을 두고 수학적 모델로 표현했다. 우리는 알고리즘의 실제 구현을 위해 작업 중이며 후속 작업에서 성능 특성을 보고 할 예정이다.&lt;/p&gt;

&lt;p&gt;동시 수정으로 인해 입력을 잃지 않는 원칙은 처음에는 합리적이라고 판단되었지만 그림 6에서 볼 수 있듯이 순차 프로그램에 익숙한 애플리케이션 프로그래머에게는 문제(suprising) 상태가 되기도 한다. 애플리케이션 프로그래머의 기대치를 이해하고 동시에 수정하는 경우에는 데이터 구조를 설계하기 위해서는 더 많은 작업이 필요하다. 더 복잡한 애플리케이션을 지원하려면 스키마 언어가 필요할 것이다. 스키마 언어는 숫자가 레지스터가 아닌 카운터로 취급 되어야한다는 의미와 같은 의미론적 주석이 필요할 수도 있다.&lt;/p&gt;

&lt;p&gt;이 논문에서 정의 된 CRDT는 삽입, 삭제 및 할당 작업을 지원한다. 이 외에도 이동 오퍼레이션(순서가 지정된 목록에서 요소의 순서를 변경하거나 문서의 한 위치에서 다른 위치로 하위 트리를 이동) 및 실행/취소 오퍼레이션을 지원하는 것이 유용할 것이다. 또한 데이터 구조의 무한한 확장을 막기 위해 쓰레기 수집(garbage collection, tombstone 제거)이 필요하다.&lt;/p&gt;

&lt;p&gt;향후 작업에서 이러한 누락 된 기능을 해결할 계획이다.&lt;/p&gt;

&lt;p&gt;(Appendix 생략… 어려워서…)&lt;/p&gt;</content><author><name></name></author><summary type="html">“A Conflict-Free Replicated JSON Datatype.” 공부하면서 정리한 내용 Original paper link: link</summary></entry><entry><title type="html">Paper 01. High Responsiveness for Group Editing CRDTs. 요약</title><link href="http://localhost:4000/paper/2018/09/14/high-responsiveness-for-group-editing-crdts.html" rel="alternate" type="text/html" title="Paper 01. High Responsiveness for Group Editing CRDTs. 요약" /><published>2018-09-14T10:00:00+09:00</published><updated>2018-09-14T10:00:00+09:00</updated><id>http://localhost:4000/paper/2018/09/14/high-responsiveness-for-group-editing-crdts</id><content type="html" xml:base="http://localhost:4000/paper/2018/09/14/high-responsiveness-for-group-editing-crdts.html">&lt;p&gt;“High Responsiveness for Group Editing CRDTs.” 공부하면서 정리한 내용&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Original paper link: &lt;a href=&quot;https://pages.lip6.fr/Marc.Shapiro/papers/rgasplit-group2016-11.pdf&quot;&gt;High Responsiveness for Group Editing CRDTs.&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;high-responsiveness-for-group-editing-crdts&quot;&gt;High Responsiveness for Group Editing CRDTs.&lt;/h2&gt;

&lt;h3 id=&quot;요약&quot;&gt;요약&lt;/h3&gt;

&lt;p&gt;공동 편집에는 빠른 응답성을 위해서 OT, CRDT와 같은 Optimistic Replication 알고리즘이 사용되고 있음.
보통 CRDT가 downstream(원격) 오퍼레이션을 처리할 때 빠름(CRDT: 지수 시간, OT: 제곱 시간). 하지만 CRDT는 upstream(로컬) 오퍼레이션 처리시 선형 시간 복잡도라서 응답성이 느림&lt;/p&gt;

&lt;p&gt;이 논문은 CRDT의 앞 부분에 “identifier data structure”라는 보조 데이터 타입을 제공해서 upstream 오퍼레이션 처리를 개선하는 방법을 제안함. identifier data structure는 동기화나 복제를 필요로 하지 않음.&lt;/p&gt;

&lt;p&gt;identifier data structure를 블록 단위 저장 접근 방식과 함께 사용하면 upstream 실행을 상당히 개선할 수 있음(무시해도 되는 정도의 메모리, 네트워크, downstream 실행 시간이 추가됨).&lt;/p&gt;

&lt;h3 id=&quot;1-도입&quot;&gt;1. 도입&lt;/h3&gt;

&lt;h4 id=&quot;optimistic-replication&quot;&gt;Optimistic Replication&lt;/h4&gt;

&lt;p&gt;공동 편집에는 응답성이 매우 중요하므로 네트워크 지연이나 문서의 락에 영향을 받지 않도록 모든 유저는 자신의 디바이스에 편집하는 문서의 리플리카를 갖고 있는데, 이를 Optimistic Replication이라 부른다.
사용자의 편집 오퍼레이션은 로컬 리플리카에 먼저 반영되고 원격에 있는 다른 사용자의 리플리카에 전송된다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;upstream 실행: 로컬 오퍼레이션을 처리&lt;/li&gt;
  &lt;li&gt;downstream 실행: 다른 사용자가 전송한 원격 오퍼레이션을 처리, 임의의 동시 편집도 해결 해야함&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;ot&quot;&gt;OT&lt;/h4&gt;

&lt;p&gt;OT는 upstream의 빠른 응답성으로 공동 편집에 사용되었지만, 각 리플리카의 히스토리를 재정렬하고 오퍼레이션을 변환해야 하므로 downstream의 처리 속도가 특히 분산 환경에서 매우 느림(O(N^2k), N: 오퍼레이션의 수, k: 리플리카 수).&lt;/p&gt;

&lt;h4 id=&quot;crdt&quot;&gt;CRDT&lt;/h4&gt;

&lt;p&gt;이를 해결하기 위해서 CRDT가 도입되었고 교환 법칙(commutative)의 오퍼레이션을 사용해서 downstream 실행시 리플리카의 일관성을 위해서 오퍼레이션을 별도로 변환하거나 정렬할 필요가 없다.
하지만 보통 CRDT 유형의 알고리즘은 upstream 처리시에 고유한 identifier를 생성하거나 조회되어야 하므로 upstream 처리가 느린 경향이 있다.&lt;/p&gt;

&lt;h4 id=&quot;block-wise-approach&quot;&gt;Block-wise approach&lt;/h4&gt;

&lt;p&gt;이를 개선하는 첫 제안은 문자를 하나하나 저장하지 않고 블록 단위로 저장하는 것이었는데, 고유한 identifier를 갖는 요소들이 줄어드므로 선형적인 처리시 유리했고 각 요소가 고유한 identifier와 같이 메타데이터를 갖고 있었으므로 메모리도 작게 사용했다. 하지만 블록으로 연결했다고 하지만 여전히 선형 시간의 복잡도를 갖고 있다.&lt;/p&gt;

&lt;h4 id=&quot;identifier-data-structure&quot;&gt;Identifier data structure&lt;/h4&gt;

&lt;p&gt;이 논문은 upstream 처리 시간을 상당히 개선할 수 있으며 대부분의 CRDT 알고리즘에 적용할 수 있는 Identifier data structure를 제안하는데, 이는 각 피어(peer)가 자신의 독립적인 구조를 갖고 있으므로 동기화 할 필요가 없고 동시성 이슈를 고려할 필요가 없다. Identifier data structure를 도입하면 본래의 알고리즘에 비해서 네트워크, 메모리 그리고 downstream 처리에 약간의 간접 비용이 있지만 무시할 정도다.&lt;/p&gt;

&lt;h3 id=&quot;2-배경-관련-crdt들&quot;&gt;2. 배경, 관련 CRDT들&lt;/h3&gt;

&lt;h4 id=&quot;231--woot&quot;&gt;2.3.1  WOOT&lt;/h4&gt;

&lt;p&gt;WOOT에서 identifier는 피어의 아이디와 삽입시 좌우측의 두 앨리먼트에 대한 링크로 구성된다. 결정론적 알고리즘으로 동일한 구역에서 요소들이 동일한 순서를 갖지만, 매우 복잡하고 처리 비용이 크다. 각 요소의 위치가 이웃 요소와 관계에 의해 결정되므로 완전히 삭제하기가 어려워서 tombstone을 사용한다. WOOT의 최적화 버전이 제안되었지만, downstream 처리 속도만 개선되었다.&lt;/p&gt;

&lt;h4 id=&quot;232-treedoc&quot;&gt;2.3.2 TreeDoc&lt;/h4&gt;

&lt;p&gt;요소의 비균형 이진 탐색트리로 요소의 identifier는 트리에서의 Path이다. 이진탐색이 가능하지만, 트리가 비균형이므로 문서의 끝에 계속해서 텍스트를 입력할 경우, 균형이 깨져서 고비용이 발생한다. 모든 피어에서 트리의 모양이 동일하며, 균형을 맞추려면 모든 피어를 동기화 해야하므로 균형을 잡는 것은 불가능하다. tombstone을 사용하지만, 특정 조건에서 제거가 가능하다.&lt;/p&gt;

&lt;h4 id=&quot;233-logoot&quot;&gt;2.3.3 Logoot&lt;/h4&gt;

&lt;p&gt;어휘 순서를 사용해서 문서의 요소의 순서를 잡는다. identifier는 3개의 정수형 튜플(1: 우선순위, 2: Upstream 피어 ID, 3: Upstream 논리 시계)의 리스트다. identifier는 배열에 저장되며, 새로운 요소 삽입을 위해서는 배열의 shift가 발생한다. (생략)&lt;/p&gt;

&lt;h4 id=&quot;234-logootsplit&quot;&gt;2.3.4 LogootSplit&lt;/h4&gt;

&lt;p&gt;Logoot의 블록버전 (생략)&lt;/p&gt;

&lt;h4 id=&quot;235-rga&quot;&gt;2.3.5 RGA&lt;/h4&gt;

&lt;p&gt;RGA는 문서에서 모든 요소는 특정 요소 뒤에 추가된다는 점을 이용한다. RGA 자료구조는 링크드 리스트로 각 요소는 내용과 다음 요소의 링크, tombstone으로 구성된다. identifier는 피어 ID, sum(삽입중 upstream 벡터 시계의 합)으로 구성된다. identifier의 순서는 피어 ID와 sum으로 판단된다.&lt;/p&gt;

&lt;h4 id=&quot;24-요약&quot;&gt;2.4 요약&lt;/h4&gt;

&lt;p&gt;빠른 반응성을 위해서 upstream에서 로그 시간 복잡도가 필요하지만, 이전 알고리즘은 이를 제공하지 못했다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;OT는 TTF tombstone&lt;/li&gt;
  &lt;li&gt;RGA와 WOOT는 tombstone&lt;/li&gt;
  &lt;li&gt;Logoot는 자체 배열을 shift해야 했으며, LogootSplit은 identifier를 관리해야 함&lt;/li&gt;
  &lt;li&gt;Treedoc은 불균형 트리를 탐색해야 함&lt;/li&gt;
  &lt;li&gt;Block 접근방식은 블록 크기에 의존적&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;사용성에 직결되는 upstream 실행시간은 매우 중요했다. RGA는 downstream 실행이 매우 우수했다.&lt;/p&gt;

&lt;h3 id=&quot;3-identifier-자료구조&quot;&gt;3. Identifier 자료구조&lt;/h3&gt;

&lt;p&gt;이 논문에서는 각 피어마다 본 알고리즘에 영향도가 작은 Identifier 자료구조를 제안한다. upstream 실행시간을 로그시간으로 수행한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/2018-09-14-high-responsiven/fe21ad0c-b50e-11e8-90df-507ecf589d46&quot; alt=&quot;screen shot 2018-09-07 at 2 27 56 pm&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;스텝 1: 사용자 액션&lt;/li&gt;
  &lt;li&gt;스텝 2: 사용자의 액션으로부터 Identifier 자료구조를 사용해서 Node를 조회&lt;/li&gt;
  &lt;li&gt;스텝 3-5: 본 알고리즘과 동일한 복제 과정&lt;/li&gt;
  &lt;li&gt;스텝 6-7: 원격 오퍼레이션을 받아서 로컬 Identifier 자료구조를 업데이트&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;idNode는 Node를 참조를 갖고 있고 반대로 Node는 idNode의 참조를 갖고 있다.&lt;/p&gt;

&lt;h4 id=&quot;31-crdt-identifier를-조회하기&quot;&gt;3.1 CRDT identifier를 조회하기&lt;/h4&gt;

&lt;p&gt;RGA와 WOOT, LogooSplit에서 문서의 노드를 조회할 때 시작작 노드부터 찾는 위치의 노드를 만날때 까지 선형탐색 한다(O(N)).&lt;/p&gt;

&lt;p&gt;Identifier 자료구조는 사용자의 수정 위치를 입력받아서 CRDT identifier를 빠르게 찾는 역할을 한다. Identifier가 순서를 갖고 있다면, Identifier 자료구조는 스킵 리스트와 같은 SortedMap이거나 혹은 weighted binary tree가 될 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/2018-09-14-high-responsiven/10a1c958-b50f-11e8-8df6-283fcd58f2b2&quot; alt=&quot;screen shot 2018-09-10 at 9 13 35 am&quot; /&gt;&lt;/p&gt;

&lt;p&gt;RGA에 identifier 자료구조(weighted tree)를 적용할 경우&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;idNode: 레퍼런스(left child, right child, parent)와 weight(하위 트리의 전체 크기), RGA 노드의 참조&lt;/li&gt;
  &lt;li&gt;RGA Node: 기본 (identifier, 내용, next 레퍼런스, tombstone)에 idNode의 참조 추가&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/2018-09-14-high-responsiven/1fe8bebc-b50f-11e8-898d-d41ef1e3d80f&quot; alt=&quot;screen shot 2018-09-10 at 9 23 01 am&quot; /&gt;&lt;/p&gt;

&lt;p&gt;사용자의 위치(pos)로 부터 특정 Node를 찾을 때, weight를 비교하면서 identifier를 검색&lt;/p&gt;

&lt;h4 id=&quot;32-downstream-에서-identifier-자료구조-업데이트하기&quot;&gt;3.2 downstream 에서 identifier 자료구조 업데이트하기&lt;/h4&gt;

&lt;p&gt;RGA에서 삽입 오퍼레이션에는 대상 노드의 identifier와 새로운 값이 포함되어 있다. 이 논문에서는 downstream에서 RGA의 기본 알고리즘으로 대상 노드가 찾아진 뒤에 identifier 자료구조를 업데이트 한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/2018-09-14-high-responsiven/2c41abd8-b50f-11e8-8d4c-508c65dc57ad&quot; alt=&quot;screen shot 2018-09-10 at 9 38 08 am&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Identifier 자료구조는 tombstone 노드를 포함하지 않으므로 deletion에는 아무처리를 하지 않고 insertion의 경우 아래와 같은 로직을 수행한다.&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;(XXX: 삭제시에도 대상 idNode를 삭제하고 weight를 업데이트 해야한다).&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/2018-09-14-high-responsiven/38e1c12a-b50f-11e8-9473-421d9ffc3083&quot; alt=&quot;screen shot 2018-09-10 at 9 51 54 am&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;33-identifier-자료구조-logoot에-적용&quot;&gt;3.3 identifier 자료구조 Logoot에 적용&lt;/h4&gt;
&lt;p&gt;(생략)&lt;/p&gt;

&lt;h3 id=&quot;4-rgatreesplit-rga--블록화--identifier-자료구조&quot;&gt;4. RGATreeSplit: RGA + 블록화 + identifier 자료구조&lt;/h3&gt;

&lt;p&gt;논문에서는 RGA가 downstream 실행에 가장 효율적인 알고리즘이고 블록 알고리즘을 적용하면, upstream과 downstream 실행을 모두 개선하므로 identifier 자료구조를 포함한 RGATreeSplit을 제안함.&lt;/p&gt;

&lt;h4 id=&quot;41-block-wise-rga-rga--블록화&quot;&gt;4.1 block-wise RGA: RGA + 블록화&lt;/h4&gt;

&lt;p&gt;이 논문에서는 block-wise RGA에는 “W. Yu. A string-wise CRDT for group editing.”에서 제안한 split과 offset 개념을 추가했다.&lt;/p&gt;

&lt;p&gt;각 노드는 다음 속성을 갖고 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;content: 메모리 효율을 위해서 tombstone화 되면, 제거 될 수 있다.&lt;/li&gt;
  &lt;li&gt;identifier: 기존 RGA identifier&lt;/li&gt;
  &lt;li&gt;nextLink: 기존 RGA의 다음 노드의 참조&lt;/li&gt;
  &lt;li&gt;offset: 사용자가 삽입한 본 위치&lt;/li&gt;
  &lt;li&gt;splitLink: split시에 다음 노드의 참조&lt;/li&gt;
  &lt;li&gt;length: 본문의 크기&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;offset x에 있는 노드를 pos로 split하면, 첫 노드의 offset은 x, 두 번째 노드의 offset은 x + pos&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/2018-09-14-high-responsiven/46c07a70-b50f-11e8-8165-7658b7743483&quot; alt=&quot;screen shot 2018-09-10 at 10 07 34 am&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;리플리카 1에서 사용자가 “ABCDEF” 삽입, identifier 는 [[1, 0], 0]&lt;/li&gt;
  &lt;li&gt;리플리카 2에서 “ABCDEF”를 전달받고 사용자가 “XY”를 pos 3에 추가, identifier 는 [[2, 1], 0]
 “ABCDEF” 블록은 “ABC”, identifier [[1, 0], 0]와 “DEF”, identifier [[1, 0], 3]로 쪼개짐&lt;/li&gt;
  &lt;li&gt;리플리카 2에서 “56789”를 마지막에 삽입 identifier는 [[2, 2], 0]&lt;/li&gt;
  &lt;li&gt;리플리카 2에서 “78” 삭제 “56789” 블록은 (“56” identifier [[2,2],0])과 (tombstone, identifier [[2, 2], 2])그리고 (“9” identifier [[2, 2], 4])로 쪼개짐.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;FINDOFFSET: identifier와 offset을 입력받아서 특정 node를 찾는 함수&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/2018-09-14-high-responsiven/508ff13e-b50f-11e8-9f91-3d5ebd6e3b84&quot; alt=&quot;screen shot 2018-09-10 at 10 23 17 am&quot; /&gt;&lt;/p&gt;

&lt;p&gt;splitLink는 identifier와 offset을 기준으로 특정 노드를 찾을 때, 성능을 위해 사용함.&lt;/p&gt;

&lt;h4 id=&quot;42-rgatreesplit의-identifier-자료구조&quot;&gt;4.2 RGATreeSplit의 identifier 자료구조&lt;/h4&gt;

&lt;p&gt;기본적으로 3절과 비슷하지만, 몇 가지 차이가 있음&lt;/p&gt;

&lt;p&gt;첫째. Identifier 자료구조와 findPosInIdentifierTree 함수의 weight에 블록 content의 크기를 반영한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/2018-09-14-high-responsiven/5b4de342-b50f-11e8-890b-ed6046b935e7&quot; alt=&quot;screen shot 2018-09-10 at 10 31 21 am&quot; /&gt;&lt;/p&gt;

&lt;p&gt;둘째. 오퍼레이션 반영시에 대상 노드를 분할해야 한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/2018-09-14-high-responsiven/6855f8c2-b50f-11e8-83c1-2a30ab65a931&quot; alt=&quot;screen shot 2018-09-10 at 1 37 57 pm&quot; /&gt;&lt;/p&gt;

&lt;p&gt;삽입 오퍼레이션은 3개(2개: 기존 노드 split, 1개: 새로운 노드)의 새로운 블록을 만들어야한다. 간단한 방법은 기존 노드를 새로운 노드의 값으로 치환하고 새로운 노드 좌측(insertBefore))과 우측(insertAfter)에 2개의 split 노드를 삽입하는 방법이다.&lt;/p&gt;

&lt;h3 id=&quot;5-평가와-실험&quot;&gt;5. 평가와 실험&lt;/h3&gt;
&lt;h4 id=&quot;51-구현&quot;&gt;5.1 구현&lt;/h4&gt;

&lt;p&gt;3절의 identifier 자료구조로 Binary weighted tree를 도입하는 경우 balanced 혹은 unbalanced(주기적 balance)의 두가지 구현 방식이 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;RGA, Logoot: TreeList(AVL 기반), 단순한 구현위해 downstream에도 별도 hashtable 없이 TreeList로 찾음&lt;/li&gt;
  &lt;li&gt;RGATreeSplit: weighted unbalanced binary tree(주기적으로 리밸런싱 수행), 리밸런싱 처리도중 응답성이 떨어질 수 있으므로 사용자가 편집을 잠시 쉬는 동안 실행 권장(실험용 구현이라 그냥 이렇게 함…)&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;52-실험&quot;&gt;5.2 실험&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;노드: Intel Xeon X3440 processors (2.53GHz), 16GB of RAM, Wheezy-x64-big-1.0 operating systems on Debian. 싱글 쓰레드.&lt;/li&gt;
  &lt;li&gt;입력: 사용자 수정 오퍼레이션을 무작위로 생성했으며, 모든 알고리즘에 대해 동일한 세트 사용&lt;/li&gt;
  &lt;li&gt;오퍼레이션의 수와 순서가 서로 다른 여섯 개의 실험(5000, 10000, 15000, 20000, 30000 및 40000개)
    &lt;h4 id=&quot;53-싱글-엘리먼트-시리즈&quot;&gt;5.3 싱글 엘리먼트 시리즈&lt;/h4&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/2018-09-14-high-responsiven/72babc58-b50f-11e8-9eab-45bf8b0457ce&quot; alt=&quot;screen shot 2018-09-10 at 3 03 25 pm&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/2018-09-14-high-responsiven/7a1e946a-b50f-11e8-8ad9-3d8723fcf8a5&quot; alt=&quot;screen shot 2018-09-10 at 3 03 49 pm&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;입력 오퍼레이션 특징: 한 요소에만 영향을 주는 수정&lt;/li&gt;
  &lt;li&gt;RGA와 RGASplit 성능이 비슷, RGATreeList와 RGATreeSplit도 성능이 비슷&lt;/li&gt;
  &lt;li&gt;예상한 대로 identifier 자료구조를 사용한 경우 upstream에서 매우 성능이 빨라짐&lt;/li&gt;
  &lt;li&gt;downstream에서 identifier 자료구조 + RGA는 성능이 소폭 하락(identifier 자료구조 업데이트 해야 하므로)&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;54-블록-시리즈-수정&quot;&gt;5.4 블록 시리즈 수정&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/2018-09-14-high-responsiven/8538104c-b50f-11e8-867e-423ebea739ac&quot; alt=&quot;screen shot 2018-09-10 at 2 05 38 pm&quot; /&gt;
&lt;img src=&quot;/assets/img/2018-09-14-high-responsiven/8d6678bc-b50f-11e8-8c69-5bec9f3f5764&quot; alt=&quot;screen shot 2018-09-10 at 3 12 39 pm&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;입력 오퍼레이션 특징: 80% 한 요소 수정과 20% 블록 수정, 블록의 평균 길이 20개&lt;/li&gt;
  &lt;li&gt;블록 기반 알고리즘이 기본 알고리즘보다 upstream과 downstream 모두에서 성능이 향상되었지만 빠른 응답을 위해 충분하지 않음&lt;/li&gt;
  &lt;li&gt;RGASplit은 시간이 지남에 따라 성능이 저하 됨.&lt;/li&gt;
  &lt;li&gt;LogootSplitAVL, TreeDoc은 원래의 RGA 알고리즘보다 다운 스트림 성능이 떨어짐&lt;/li&gt;
  &lt;li&gt;RGATreeSplit은 전반적인 성능이 가장 좋음&lt;/li&gt;
  &lt;li&gt;LogootTree는 RGATreeSplit보다 성능이 떨어지지만 블록 관리가 없어도 LogootSplitAVL과 유사한 성능 보임&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;6-결론&quot;&gt;6. 결론&lt;/h3&gt;

&lt;p&gt;이 논문에서는 CRDT 알고리즘의 응답성을 향상 시키기 위해서 블록 단위 알고리즘과 log 시간 복잡도를 위한 추가 identifier 자료구조를 제안한다. 특히, 사용자의 수정 사항을 반영하는 upstream 을 크게 개선되므로 체감 속도를 크게 향상된다.&lt;/p&gt;</content><author><name></name></author><summary type="html">“High Responsiveness for Group Editing CRDTs.” 공부하면서 정리한 내용 Original paper link: High Responsiveness for Group Editing CRDTs.</summary></entry><entry><title type="html">Idea 06. Talk is cheap. Show me the code.</title><link href="http://localhost:4000/idea/2017/08/29/talk-is-cheap-show-me-the-code.html" rel="alternate" type="text/html" title="Idea 06. Talk is cheap. Show me the code." /><published>2017-08-29T21:04:00+09:00</published><updated>2017-08-29T21:04:00+09:00</updated><id>http://localhost:4000/idea/2017/08/29/talk-is-cheap-show-me-the-code</id><content type="html" xml:base="http://localhost:4000/idea/2017/08/29/talk-is-cheap-show-me-the-code.html">&lt;blockquote&gt;
  &lt;p&gt;“Talk is cheap. Show me the code.” from Linus Torvalds&lt;/p&gt;
&lt;/blockquote&gt;</content><author><name></name></author><summary type="html">“Talk is cheap. Show me the code.” from Linus Torvalds</summary></entry><entry><title type="html">Idea 05. 디자인 태도</title><link href="http://localhost:4000/idea/2011/12/17/design-attitude.html" rel="alternate" type="text/html" title="Idea 05. 디자인 태도" /><published>2011-12-17T11:31:00+09:00</published><updated>2011-12-17T11:31:00+09:00</updated><id>http://localhost:4000/idea/2011/12/17/design-attitude</id><content type="html" xml:base="http://localhost:4000/idea/2011/12/17/design-attitude.html">&lt;p&gt;좋은 디자인으로 변경하자고 제안할 때 “이미 돌아가는 것을 왜 바꾸느냐?” 혹은 “이것은 예전에 합의한 것인데 왜 바꾸느냐?” 라는 이야기를 듣는 경우가 종종 있다.&lt;/p&gt;

&lt;p&gt;바꾸는 가장 큰 이유는 현재의 나쁜 아이디어를 고수하는 것은 가능성을 잃어버리게 하기 때문이다. 문제는 나쁜 아이디어를 만든 것보다 그것을 고수하는 것에 있다. 이것은 우리의 발목을 잡는다. 이런 집착은 탐색을 지속하며 더 나은 것을 찾기 어렵게 한다. 더 좋은 아이디어가 발견 될때 자신의 어설픈 아이디어가 옳았다는 것을 증명하거나 방어하는 것에 시간과 힘을 쓰지 말고 더 나은 아이디어를 선택할 수 있는 용기가 필요하다.&lt;/p&gt;

&lt;p&gt;우리는 중요한 사안을 너무 쉽게 결정하고 그것에 매몰되는 것은 아닌지 생각해봐야한다. 우리가 믿었던 최소 단위 원자도 쪼개지는 마당에 변경 불가능한 아이디어는 없다. 모든 아이디어는 더 나은 아이디어가 발견 될때까지 사용한다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;‘디자인 태도’란 어설픈 아이디어를 솎아내고 최후의 좋은 아이디어들을 고를 때까지 여러 가능성을 생각해보고 방향이 잡힐때까지는 ‘모든 것을 뒤집어 고려할 수 있는 의지’를 포함한다. - 비즈니스 모델의 탄생 중&lt;/p&gt;
&lt;/blockquote&gt;</content><author><name></name></author><summary type="html">좋은 디자인으로 변경하자고 제안할 때 “이미 돌아가는 것을 왜 바꾸느냐?” 혹은 “이것은 예전에 합의한 것인데 왜 바꾸느냐?” 라는 이야기를 듣는 경우가 종종 있다.</summary></entry><entry><title type="html">Idea 04. 소프트웨어 품질과 개발문화</title><link href="http://localhost:4000/idea/2011/11/28/quality_and_culture.html" rel="alternate" type="text/html" title="Idea 04. 소프트웨어 품질과 개발문화" /><published>2011-11-28T18:34:00+09:00</published><updated>2011-11-28T18:34:00+09:00</updated><id>http://localhost:4000/idea/2011/11/28/quality_and_culture</id><content type="html" xml:base="http://localhost:4000/idea/2011/11/28/quality_and_culture.html">&lt;p&gt;나와 팀은 지난 몇몇 프로젝트를 진행하는 중 소프트웨어의 품질이 개발팀의 건전한 개발문화를 통해 향상된다고 믿게 되었다. 우리가 발견하고 적용한 건전한 개발문화란 어떤 것이 있을까?&lt;/p&gt;

&lt;p&gt;첫번째. 소스코드 공동 소유다.&lt;/p&gt;

&lt;p&gt;소스코드는 개인의 소유가 아닌 팀의 공동 소유물이다. 이는 팀원들의 솔직한 커뮤니케이션 통해 이루어질 수 있다.&lt;/p&gt;

&lt;p&gt;소스코드나 일감이 개인의 소유일 경우 개인은 자신의 탑을 쌓을 확률이 높아진다. (여기서 말하는 탑은 혼자만 고칠 수 있는 코드 혹은 잘못되었지만 그 사실을 숨기고 있고 남에게 보여주기 싫은 코드,… 등이 있다.) 이런 상황에서 개발자는 메니저에게 비이상적인 개발일정을 보고하기도하고 특정한 변경이 불가능하다고 자신의 구조를 방어하기도 한다.&lt;/p&gt;

&lt;p&gt;팀이 소스코드를 공동 소유물로 여긴다면 소스코드는 더욱 건전해지고 개개인들이 만드는 기능 사이에 중복기능을 구현할 확률도 줄일 수 있다.&lt;/p&gt;

&lt;p&gt;특히 어려운 문제의 알고리즘이나 프로그램 전체의 아키텍쳐에 대해서는 상호 리뷰 혹은 짝프로그래밍이 필수 이다. 여기서 팀은 어려운 문제를 개인에게 맡기지 않고 팀의 문제로 가져간다. 주로 짝프로그래밍을 활용하는데 개인이 내리기 힘든의사 결정을 최소 두 명이상이 고민하여 결정하도록 한다. 혼자 A가 좋을까 B가 좋을까 생각하지 않고 토론을 통해서 A혹은 B를 결정한다. 역시 혼자 진행하는 것에 비해 빠른 의사 결정이 이루어진다.&lt;/p&gt;

&lt;p&gt;팀원들은 상대방의 코드를 활발하게 리딩해야한다. 이때 팀의 커뮤니케이션이 소스코드를 통해서 이루어지기도 한다. 상대방의 코드를 탐색하고 잘못된 부분에 이의를 제기해야하고 서로 이야기한 결과 잘못되었으면 과감히 수정하거나 삭제해야한다. 여기서 작성자는 자신의 코드가 지워진다는 생각은 내려놔야 한다. 코드는 팀의 소유물이니까…&lt;/p&gt;

&lt;p&gt;공동 소유가 제대로 적용된 결과로는 마치 한명이 짠 것과 같은 코딩 스타일과 프로그램 구조가 나오게 된다.&lt;/p&gt;

&lt;p&gt;두번째. 팀 학습&lt;/p&gt;

&lt;p&gt;두번째 말하고자 하는 건전한 개발 문화는 바로 팀 학습이다.&lt;/p&gt;

&lt;p&gt;팀원 중 한 사람이 새로운 프로그래밍 패러다임이나 프레임워크에 대해 공부를 한다. 그리고 자기가 알게된 내용을 팀에 전파한다. 이는 자체 세미나를 통해서 전파되기도 하고 짝프로그래밍을 통해서 전파되기도 한다. 개인 모두가 새로운 주제에 대해서 각자 공부하는 것이 아니고 관심깊게 본 다른 사람을 통해 배운다.&lt;/p&gt;

&lt;p&gt;나의 경험으로는 팀원 중 한 사람이 Functional Programming을 공부하고 리스트 처리에 대한 프레임워크를 만들어서 다른 팀원들이 좀 더 비즈니스 로직에 집중 할수 있게 도왔던적이 있다. 그 결과 개발팀은 개발 속도가 향상시킬 수 있었고 전체 소스코드의 양 또한 줄일 수 있었다.&lt;/p&gt;

&lt;p&gt;학습의 주제가 꼭 기술적인 것일 필요는 없다. 팀의 프로젝트를 도울 수 있는 어떤 것이든 상관이 없다. 예) 플레닝 포커, …&lt;/p&gt;

&lt;p&gt;건전한 개발문화를 통해 발전된 팀은 개개인의 능력도 뛰어나고 전체적으로 볼때는 한몸처럼 움직일 것이다.&lt;/p&gt;</content><author><name></name></author><summary type="html">나와 팀은 지난 몇몇 프로젝트를 진행하는 중 소프트웨어의 품질이 개발팀의 건전한 개발문화를 통해 향상된다고 믿게 되었다. 우리가 발견하고 적용한 건전한 개발문화란 어떤 것이 있을까?</summary></entry><entry><title type="html">Idea 03. 증상만 치료하지 말고, 원인을 제거하라.</title><link href="http://localhost:4000/idea/2011/11/14/eliminate-cause.html" rel="alternate" type="text/html" title="Idea 03. 증상만 치료하지 말고, 원인을 제거하라." /><published>2011-11-14T23:09:00+09:00</published><updated>2011-11-14T23:09:00+09:00</updated><id>http://localhost:4000/idea/2011/11/14/eliminate-cause</id><content type="html" xml:base="http://localhost:4000/idea/2011/11/14/eliminate-cause.html">&lt;blockquote&gt;
  &lt;p&gt;엔토니 로빈스(anthoy Robbins)는 그의 책 [내 안의 거인을 일깨우자]에서 어떤 의사의 이야기를 하고 있다. 한 의사가 물살이 빠른 강의 제방에 서 있다가, 물에 떠내려가며 살려 달라고 외치는 비명소리를 들었다. 자기 이외에는 도와줄 사람이 없다는 것을 안 그 의사는, 주저하지 않고 물 속으로 뛰어들었다. 물에 빠진 사람을 강가로 끌어 낸 뒤, 의사는, 주저하지 않고 물 속으로 뛰어들었다. 물에 빠진 사람을 강가로 끌어 낸 뒤, 의사는 인공 호흡으로 그를 소생시키려 했다. 그런데 그가 소생되기도 전에, 강에서 두 사람의 비명 소리가 들려왔다. 의사가 두 사람을 구조하여 소생시키기 무섭게, 강에서는 또다시 네사람의 비명소리가 들려 왔다. 이어서, 여덟명의 비명이 들려 왔다… 안타깝게도, 이 의사는 사람들을 구조하기에 너무 바쁜 나머지, 상류로 올라가서 도대체 누가 사람들을 물에 빠뜨리는가 찾아 볼 시간이 없었다.&lt;/p&gt;

  &lt;p&gt;Writing Solid Code P. 273 증상만 치료하는 의사
증상만 치료하지 말고, 원인을 제거하라.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;프로젝트를 진행하다 보면 개발 경험이 풍부한 개발자 임에도 불구하고 이런 실수를 저지르는 것을 자주 목격한다.&lt;/p&gt;

&lt;p&gt;계속 발전 하고 싶으면 원인을 제거하라고 말하고 싶다.&lt;/p&gt;</content><author><name></name></author><summary type="html">엔토니 로빈스(anthoy Robbins)는 그의 책 [내 안의 거인을 일깨우자]에서 어떤 의사의 이야기를 하고 있다. 한 의사가 물살이 빠른 강의 제방에 서 있다가, 물에 떠내려가며 살려 달라고 외치는 비명소리를 들었다. 자기 이외에는 도와줄 사람이 없다는 것을 안 그 의사는, 주저하지 않고 물 속으로 뛰어들었다. 물에 빠진 사람을 강가로 끌어 낸 뒤, 의사는, 주저하지 않고 물 속으로 뛰어들었다. 물에 빠진 사람을 강가로 끌어 낸 뒤, 의사는 인공 호흡으로 그를 소생시키려 했다. 그런데 그가 소생되기도 전에, 강에서 두 사람의 비명 소리가 들려왔다. 의사가 두 사람을 구조하여 소생시키기 무섭게, 강에서는 또다시 네사람의 비명소리가 들려 왔다. 이어서, 여덟명의 비명이 들려 왔다… 안타깝게도, 이 의사는 사람들을 구조하기에 너무 바쁜 나머지, 상류로 올라가서 도대체 누가 사람들을 물에 빠뜨리는가 찾아 볼 시간이 없었다. Writing Solid Code P. 273 증상만 치료하는 의사 증상만 치료하지 말고, 원인을 제거하라.</summary></entry><entry><title type="html">Idea 02. 소프트웨어, 건축물과 정원</title><link href="http://localhost:4000/idea/2011/09/28/brida.html" rel="alternate" type="text/html" title="Idea 02. 소프트웨어, 건축물과 정원" /><published>2011-09-28T03:58:00+09:00</published><updated>2011-09-28T03:58:00+09:00</updated><id>http://localhost:4000/idea/2011/09/28/brida</id><content type="html" xml:base="http://localhost:4000/idea/2011/09/28/brida.html">&lt;p&gt;파울로 코엘료의 “브리다” 의 들어가는 말에 아래와 같은 글이 적혀 있다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;건물을 세우는 사람들은 그 일에 몇 년이라는 세월을 바치기도 하지만, 결국 언젠가는 그 일을 끝내게 됩니다. 그리고 그 일을 마치는 순간, 그는 자신이 쌓아올린 벽 안에 갇히게 됩니다. 건물을 세우는 일이 끝나면, 그 삶은 의미를 잃게 되는 것입니다.
하지만 정원을 일구는 사람들도 있습니다. 그들은 몰아치는 폭풍우와 끊임없이 변화하는 계절에 맞서 늘 고생하고 쉴 틈이 없습니다. 하지만 건물과는 달리 정원은 결코 성장을 멈추지 않습니다. 또한 정원은 그것을 일구는 사람의 관심을 요구하는 동시에 그의 삶에 위대한 모험이 함께할 수 있도록 해 줍니다. 정원을 일구는 사람들은 서로를 알아봅니다. 그들은 알고 있기 때문입니다. 식물 한 포기 한 포기의 역사 속에 온 세상의 성장이 깃들어 있음을…&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;이것을 읽고 소프트웨어 생각이나는 것은 왜 일까?
지속적인 성장을 하는 소프트웨어와 그렇지 않은 소프트웨어를 보았기 때문이다.&lt;/p&gt;</content><author><name></name></author><summary type="html">파울로 코엘료의 “브리다” 의 들어가는 말에 아래와 같은 글이 적혀 있다.</summary></entry><entry><title type="html">Idea 01. 토끼굴 속으로</title><link href="http://localhost:4000/idea/2011/04/25/down-the-rabbit-hole.html" rel="alternate" type="text/html" title="Idea 01. 토끼굴 속으로" /><published>2011-04-25T21:15:00+09:00</published><updated>2011-04-25T21:15:00+09:00</updated><id>http://localhost:4000/idea/2011/04/25/down-the-rabbit-hole</id><content type="html" xml:base="http://localhost:4000/idea/2011/04/25/down-the-rabbit-hole.html">&lt;p&gt;영화 매트릭스(Matrix)에서 모피어스는 주인공 네오(키아누 리브스 분)에게 빨간색 약과 파란색 약 중 하나를 선택하라고 말한다. 파란색 약을 먹는다면 매트릭스의 세계 속에서 편하게 살 수 있었지만 네오는 ‘진짜 현실’에 대한 호기심으로 빨간색 약을 선택한다.&lt;/p&gt;

&lt;p&gt;그리고 눈앞에 펼쳐지는 광경에 경악을 금치 못한다. 앨리스가 이상한 나라를 보면서 그랬던 것처럼 말이다(영화 매트릭스는 ‘이상한 나라의 앨리스’에 대한 오마쥬 영화이다. 초반부에 나오는 ‘흰 토끼를 따라가라’는 암호는 ‘이상한 나라의 앨리스’의 장면을 패러디한 것이다.).&lt;/p&gt;

&lt;p&gt;네오와 앨리스는 바로 ‘호기심’ 때문에 편안하게 살아감을 포기하고 각각 빨간약, 토끼굴을 선택했다.&lt;/p&gt;

&lt;p&gt;메트릭스 속의 사람들은 프로그래밍 된 사회의 이미지를 소비한다. 그곳에서 나름 만족을 하며 살아가지만 실제 세상(메트릭스 밖)을 알지는 못한다. 심지어 메트릭스를 벗어난 한 사람이 다시 메트릭스에 들어가기를 원하는 장면도 나온다.&lt;/p&gt;

&lt;p&gt;하지만 호기심이 많은 사람들은 진실을 알고 싶어하고 또 모험을 갈망한다. 자신이 속한 시스템에 맞춰서 살기보다는 뭔가 다른 것을 찾기를 원한다. 위험을 감수해야 하지만 모험은 언제나 매력적이기 때문이다.&lt;/p&gt;

&lt;p&gt;난 빨간약을 선택했다. 그리고 잡스옹은 스텐포드에서 이런 말을 했다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Your time is limited, so don’t waste it living someone else’s life. Don’t be trapped by dogma — which is living with the results of other people’s thinking. Don’t let the noise of others’ opinions drown out your own inner voice. And most important, have the courage to follow your heart and intuition. They somehow already know what you truly want to become. Everything else is secondary.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;타성에 젖으면 끝이다. 용기를 갖으라고…&lt;/p&gt;</content><author><name></name></author><summary type="html">영화 매트릭스(Matrix)에서 모피어스는 주인공 네오(키아누 리브스 분)에게 빨간색 약과 파란색 약 중 하나를 선택하라고 말한다. 파란색 약을 먹는다면 매트릭스의 세계 속에서 편하게 살 수 있었지만 네오는 ‘진짜 현실’에 대한 호기심으로 빨간색 약을 선택한다.</summary></entry><entry><title type="html">Idea 00. 유능하고 경험 많은 개발자는 어디에 모여 살까?</title><link href="http://localhost:4000/idea/2011/03/20/where-is-the-developer.html" rel="alternate" type="text/html" title="Idea 00. 유능하고 경험 많은 개발자는 어디에 모여 살까?" /><published>2011-03-20T13:15:00+09:00</published><updated>2011-03-20T13:15:00+09:00</updated><id>http://localhost:4000/idea/2011/03/20/where-is-the-developer</id><content type="html" xml:base="http://localhost:4000/idea/2011/03/20/where-is-the-developer.html">&lt;p&gt;유능하고 경험 많은 개발자는 어디에 모여 살까? 우리 개발자는 매니저가 되는 것이 목표인가?&lt;/p&gt;

&lt;p&gt;2006년 가을 개발자라는 직업을 갖게되면서부터 자연스레 생긴 궁금증이다. 5년이 다되어 가는 시간동안 경험 많은 개발자들은 보기 힘었다. 왜 대부분의 개발자들은 매니저에 비해 미숙한거 같고 어리게만 느껴질까? (실제로 대부분의 개발자는 매니저에 비해 나이가 어리거나 그들의 부하직원인것 같다.)&lt;/p&gt;

&lt;p&gt;우리는 유능한 개발자들이 특정 연차가 되었을때 심화된 엔지니어링 테크를 타는 것이 아니고 매니저 테크를 타는 것을 쉽게 목격할 수 있다. 그들의 업무는 모델링, 알고리즘 풀어먹기, 불꽃 코딩 등등에서 회의하기, 메일보내기 답하기, 회의하기, 회의하기, 회의하기, 팀원이나 프로젝트의 일정이나 스펙을 관리하기, 회의하기로 바뀐다. 이제 좀 제대로 테크닉을 발휘 하면서 후임양성할때가 되었는데 개발로 부터 자연스럽게 멀어진다.&lt;/p&gt;

&lt;p&gt;일부(특히 개발을 살짝 맛만 봤다가 운이 좋게 매니저 테크를 탄) 매니저들은 개발은 쉬운 것, 애들이나 하는 것이라고 말하기도 한다.&lt;/p&gt;

&lt;p&gt;짧은 내 경험에서 알게된  개발(여기서 말하는 개발은 주로 엔지니어링)은 어렵다. 많은 것을 공부해야한다. 다양한 프로그래밍 언어는 물론이고 때로는 큰 규모의 프로그램을 구조화 하는 모델링 기법 혹은 알고리즘들, 수학에 관련되었을 수도 있고 새로나온 플렛폼 혹은 여러가지 프로그래밍 페러다임일 수도 있다. 최적의 제품을 제대로 만들기 위해서는 반드시 무엇인 가를 알아야 하고 공부해야할 경우가 있다. 개발자는 경력이 쌓일 수록 이런 것들을 공부해야 한다.(만약 아닌것 같고 그게 이글을 읽고 있는 사람이라면 제발 공부해라.) 특정 상황에선 현재로서는 해결할 수 없는 문제가 발생되기도 한다.  끊임없이 실험하고 방법을 찾으려고 시도할때는 꿈에서도 생각할 정도로 몰입해야하는 상황도 생긴다. 개발자라는 직업이 현실에는 의사, 변호사 같은 다른 전문직보다 진입장벽이 낮지만 그들은 사실 전문가이어야하고 전문직이어야 한다. 그래야 제대로 만들 수 있다.&lt;/p&gt;

&lt;p&gt;물론 매니저라는 직업이 나쁘다는 말을 하고 싶은 것이 아니다. 그들은 프로젝트에 필요한 직업이고 해야할 일이 있다. 매니지먼트 스킬은 엔지니어링 스킬과 조금 다른 테크이다. 난 단지 유능한 개발자들이 어설픈 매니저(물론 매니저가 더 맞고 천직이라고 느껴지면 가도 좋다.)가 되지 않고 유능한 개발자로 남아서 자신이 가지고 있는 기술을 풀어 먹었으면 좋을것 같다는 생각을 하는 것이다. 그러면 좋은 소프트웨어가 좀 더 많이 나오지 않을까? 하는 생각이든다.&lt;/p&gt;</content><author><name></name></author><summary type="html">유능하고 경험 많은 개발자는 어디에 모여 살까? 우리 개발자는 매니저가 되는 것이 목표인가?</summary></entry></feed>